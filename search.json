[{"title":"基于BESNet的组织病理学图像中细胞边界分割提升方法","url":"/2019/03/26/paper-基于BESNet的组织病理学图像中细胞边界分割提升方法/","content":"\n\n\n论文题目：BESNet Boundary-Enhanced Segmentation of Cells in Histopathological Images\n论文地址：[BESNet Boundary-Enhanced Segmentation of Cells in Histopathological Images](https://link.springer.com/content/pdf/10.1007%2F978-3-030-00934-2_26.pdf)\n\n\n# 核心内容\n* 提出了一种类似于Unet的结构，但是设置了两条解码路径用来提升对细胞边界分割的精度\n* 在loss上做文章，自适应的调整权重，对边界分割较为困难的地方，进行更好的训练\n\n\n# idea的动机 \n* 图像分割中经常会出现边界分割不准确的情况，作者想要通过自适应修改loss权重的手段，有针对性的对这些分割不准确的区域进行更好的训练\n\n\n# 网络结构\n![Snipaste_2019-03-26_20-02-30.jpg](https://i.loli.net/2019/03/26/5c9a15b457a5f.jpg)\n\n* 网络结构的核心思想：训练目标细胞的边界，并利用它们的响应自适应加权整个细胞分割的训练损失。这使得能够在训练中对目标细胞较困难的部分施加更大的权重。\n* 论文所提出的结构其实很好理解，与传统Unet还是有些不一样的是这边是4层，而传统的Unet是5层，并且每一层的features的数目和Unet不一样，我感觉这边作者去除最后一层的目的在于减小参数量，论文最后也有说这种结构所导致计算量比原始Unet来的多。\n* BDP的输出是一张概率图，需要注意的是BDP训练采用的图片和MDP的图片不一样，BDP是细胞边界图片(只是标记了细胞边界即空心)，而MDP采用的是实心的图片。\n* 这边作者在结构上采用了两种跨通道连接方式，一种是summation，另一种是concatenation,我其实并不很理解这两种跨通道连接方式的区别（我感觉没太大区别）。\n\n\n# Loss\n* 在这篇文章中，作者分别对两条路径采用了不同的loss,紧接着的下面这个loss对应的BDP路径的输出，这个loss的目的在于学习边界的前景像素有多难 <br>\n![Snipaste_2019-03-26_20-02-55.jpg](https://i.loli.net/2019/03/26/5c9a15b40cf4a.jpg)\n\n* 从上面BDP loss能看出其实就是无任何修改的categorical_crossentropy loss,BDP 的输出通常在边界处表现良好，但在不太清晰或具有罕见外观类型的边界处可能会变低。这意味着BDP概率输出低的边界特征难以通过网络进行训练。为了解决这个问题，作者想到了，通过自适应加权MDP分支的损失函数，MDP对这些难以分辨的部分进行加强的训练，下面这个loss就是作者提出来的，也是本文的创新点之一：\n\n![Snipaste_2019-03-26_20-03-33.jpg](https://i.loli.net/2019/03/26/5c9a15b3e1a0a.jpg)\n\n* 其中b(x)就是BDP的输出，还有就是这边还有两个超参数需要调节（嗯。。。有点烦）。\n\n\n# 实验结果\n* 作者从Detection和Segmentation两方面来讨论自己提出的方法，下面是分别的结果\n* Detection\n![Snipaste_2019-03-26_20-04-11.jpg](https://i.loli.net/2019/03/26/5c9a15b4ada1f.jpg)\n* Segmentation\n\n![Snipaste_2019-03-26_20-04-34.jpg](https://i.loli.net/2019/03/26/5c9a15b4ae246.jpg)\n\n* 更为细节的结果\n![Snipaste_2019-03-26_20-05-14.jpg](https://i.loli.net/2019/03/26/5c9a15b4ac837.jpg)\n\n\n# 一些感悟\n* 这篇文章提出的加权重的loss与其他论文提出加权重的loss不同的是，这篇文章的loss是像素级的，也就是每个像素给的loss可能是互不相同的。\n* 我其实感觉作者作者所作的对比实验有点少，并且与之对比的是原始的Unet，Unet是2015年提出来的，结构也有些老。\n\n# 其他\n* 刚入坑深度学习的新人，有什么写的不对的地方欢迎鞭策！！！\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Paper"],"categories":["MICCAI2018-基于BESNet的组织病理学图像中细胞边界分割提升方法"]},{"title":"基于多分辨率卷积神经网络结构的共聚焦显微镜下的图像分割","url":"/2019/03/26/paper-基于多分辨率卷积神经网络结构的共聚焦显微镜下的图像分割/","content":"\n\n论文题目：A Multiresolution Convolutional Neural Network with Partial Label Training for Annotating Reflectance Confocal Microscopy Images of Skin\n\n# 核心内容\n* 提出了一种嵌套式的Unet结构，充分利用图像的多尺寸信息\n* 在嵌套的结构中加入辅助loss来帮助网络更好的进行分割\n* 与一些经典的分割算法相比取得了在Dice上取得了相当不错的成绩\n\n# idea的动机\n* 多尺度信息有助于图像分割，所以作者想尽可能的利用多尺度信息\n\n# 网络结构\n* 一般情况下为了能够充分利用多尺度信息做语意分割，通常由2种方式\n    * 将图像整合成不同的尺寸输入网络中去\n    * 在单一的网络结构中merge不同层的特征\n    * 将两种方式结合起来\n\n![Snipaste_2019-03-26_09-18-09.jpg](https://i.loli.net/2019/03/26/5c997e282d286.jpg)\n\n从网络结构图中可以很清晰的看到作者采用了第三种方式来构建自己的网络模型，其实网络结构挺简单的，大体上看下就知道是个什么意思，可惜的是作者并没有在论文中完整的提及网络模型的相关参数，在网络中，作者并不是单纯的采用了嵌套的Unet的结构，而是加入了辅助loss，这也是论文的创新点之一，作者加入辅助loss的动机是，先使用Unet网络进行粗分割，将粗分割的结果送入下一级的Unet网络,使得下一级的网络能够对结果进行细分，作者认为这种拓扑结构有利于更加连贯的分割。通过计算中间层的loss所带来的好处是1.获取深层次访问权，更新网络的更深层次系数2.训练初期，更好的去引导模型\n\n# Loss\n在某一阶层(总共三个阶层)作者采用的带权重的戴斯系数作为这一阶层的loss(应对数据不平衡),具体如下：\n![Snipaste_2019-03-26_09-18-53.jpg](https://i.loli.net/2019/03/26/5c997f8a28204.jpg)\n* $$α_{k}$$ 代表的是图片中种类k所占比重的倒数，也就是图片中k类所占图片的比重越大，系数就越小\n* $$1_{ij}$$ 代表的是图像中某一个像素点是否被label,额。。。也就是说作者用于训练的图像的金标准并不是完整的<br>\n\n完整的loss为<br>\n\n![Snipaste_2019-03-26_09-19-02.jpg](https://i.loli.net/2019/03/26/5c997e281a1f2.jpg)\n\n* 也就是说某一个阶层的loss都会与上一个阶层做一次带权重的相加，这里的M的代表的是总共使用了几个Unet结构\n* $$β_{m}$$ 代表的是作者分配给每个阶层的权重，这里作者给与的分配结果从上到下为0.8，0.16，0.04\n\n# 一些细节\n* 原始图片太大，作者采用了patch的方式进行训练\n\n# 结果\n![Snipaste_2019-03-26_09-18-35.jpg](https://i.loli.net/2019/03/26/5c997e285580c.jpg)\n* 可以看到作者得出的结果在dice上取得的效果还是很可观的\n\n\n<br><br><br><br><br><br>\n<br><br><br><br><br><br>\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Paper"],"categories":["MICCAI2018-基于多分辨率卷积神经网络结构的共聚焦显微镜下的图像分割"]},{"title":"Python入门之字符串处理","url":"/2019/03/13/Python总结(2)/","content":"# 输入与输出\n## inpute\n* 通过键盘获取数据，然后保存到指定变量中，都是按照字符串方式进行保存\n\n```python\na = input('请输入数据1:')\nb = input('请输入数据2:')\nprint(a + b)  # a,b都是按照字符串形式保存\n\na = int(input('请输入数据1:'))\nb = int(input('请输入数据2:'))\nprint(a + b)  # a,b强转int类型\n```\n    请输入数据1:1\n    请输入数据2:2\n    12\n    请输入数据1:1\n    请输入数据2:2\n    3\n\n\n## output\n### 通用格式\n* print函数中参数sep指的是当打印各个值时,各个值之间的分割方式,默认空格,end参数表示print中传入值输出完成后结束符号,默认换行\n\n```python\na = 1\nb = 2\nc = 3\nprint(a,b,c)\nprint(a,b,c,end = 'love')\nprint()\nprint(a,b,c,sep = '|')\n\nprint('-'*50)\n\nprint('a = %s'%(a)) # %s>%d>%f\nprint('a = %04s'%(a)) # 输出带4个空格\n```\n    1 2 3\n    1 2 3love\n    1|2|3\n    --------------------------------------------------\n    a = 1\n    a =    1\n\n\n### format格式\n```python\na = 1\nb = 2\nprint('{}输出{}'.format(a,b))\nprint('{1}输出{0}'.format(a,b)) #交换索引位置\nprint('{a}输出{b}{a}'.format(a = 1,b = 2))\n\nprint('-'*50)\n# 指定位置输出\nprint('{:<10}输出{}'.format('Leiy','111')) #Leiy左对齐\nprint('{:>10}输出{}'.format('Leiy','111')) #Leiy右对齐\nprint('{:^14}'.format('叶磊'))\n```\n    1输出2\n    2输出1\n    1输出21\n    --------------------------------------------------\n    Leiy      输出111\n        Leiy输出111\n        叶磊  \n\n\n# 下标和切片\n[Python入门之基本语法和数据类型][1]\n\n# 常见字符串函数\n## find\n* 检查字符串是否包含某个指定字符\n\n```python\nstr1 = 'Hello World'\n#find\nprint(str1.find('o'))#只是返回第一个所要寻找字母的所在地点\nprint(str1.find('a'))#找不到会返回 -1\nprint(str1.find('lo'))#可以寻找一个整体\nprint(str1.find('r',0,4))#限定了寻找范围的find\n```\n    4\n    -1\n    3\n    -1\n\n## index\n* 检查字符串是否包含某指定字符\n\n```python\nstr1 = 'Hello World'\n#index\nprint(str1.index('r'))#index与find不同的是当找不到的时候会报错\n```\n    8\n\n## count\n* 统计某个字符在指定范围内出现的次数\n\n```python\nstr1 = 'Hello World'\n#count\nprint(str1.count('o'))#2\nprint(str1.count('o',0,6))#同理限定范围内的寻找并计数 前闭后开\n```\n    2\n    1\n\n## replace\n* 将str1中的str1替换为str2,如果指定count,则不超过count次\n\n```python\nstr1 = 'hello world hello china'\nstr2 = str1.replace('hello','Hello',1)#这边只是替换第一个 默认是全部替换\n\nprint(str1.replace('hello','Hello'))#默认把所有的都替换掉\nprint(str1)#本质上str1无法替换 字符串无法修改只是会生成新的字符串\nprint(str2)#替换后\n```\n    Hello world Hello china\n    hello world hello china\n    Hello world hello china\n\n## split\n* 分割字符,如果maxsplit有指定值，则仅分割maxsplit个字符串\n\n```python\nstr1 = 'hello world hello china'\nprint(str1.split(' ')) #空格地方分割\nprint(str1.split('o',3)) #在小o地方分割最多分割3处\n```\n    ['hello', 'world', 'hello', 'china']\n    ['hell', ' world hello china']\n\n\n## capitalize\n* 将字符串首字母大写\n\n```python\nstr1 = 'hello world hello china'\nprint(str1.capitalize()) #第一个字母大写\n```\n    Hello world hello china\n\n## title\n* 将字符串中每个单词的首字母大写\n\n```python\nstr1 = 'hello world hello china'\nprint(str1.title()) \n```\n    Hello World Hello China\n\n## startwith & endswith\n* 检查字符串是否以obj开头,是则返回True,否则为False\n* 检查字符串是否以obj结尾,是则返回True,否则为False\n\n```python\nstr1 = 'hello world hello china'\nprint(str1.startswith('hello'))\nprint(str1.endswith('hello'))\n```\n    True\n    False\n\n## lower & upper\n* 将字符串转换为小写\n* 将字符串转换为大写\n\n```python\nstr1 = 'hello world hello china'\nprint(str1.lower())\nprint(str1.upper())\n```\n    hello world hello china\n    HELLO WORLD HELLO CHINA\n\n## ljust & rjust & center\n* 返回一个原字符串左对齐,并使用空格填充至长度width的新字符串\n* 返回一个原字符串右对齐,并使用空格填充至长度width的新字符串\n* 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串\n\n```python\nstr1 = 'hello'\nprint(str1.ljust(10))  #开辟10个位置 并且左对齐\nprint(str1.rjust(10))  #开辟10个位置 并且右对齐\nprint(str1.center(10)) #开辟10个位置 并且中间对齐\n```\n    hello     \n        hello\n    hello   \n\n## lstrip & rstrip & strip\n* 去除字符串左边空白字符\n* 去除字符串右边空白字符\n* 去除字符串两边空白字符\n\n```python\nstr1 = '     Hello     ' \nprint(str1.lstrip())#默认删除左空格 \nprint(str1.lstrip('%'))#这句话是说删除%  这里没加\nprint(str1.strip())#这句话是从两边删除\n```\n    Hello     \n        Hello     \n    Hello\n\n\n## partition\n* 可以将字符串按照str1分割成三个部分 str1前,str1, str1后\n\n```python\nstr1 = 'hello world hello china'\nprint(str1.partition('world')) #将字符串分割成三个部分 前 world 后 返回为元祖   \n```\n    ('hello ', 'world', ' hello china')\n\n## join\n* str1 中每个字符串后面插入str1,构造出一个新的字符串\n\n```python\nstr1 = '-'\nlist1 = ['hello','world','hello','china']\nprint(str1.join(list1)) #默认将,号转换为下划线  将列表转换为字符串\n```\n    hello-world-hello-china\n\n## issapce & isalnum\n* 如果str1中只包含空格,返回True,否则为False\n* 如果str1中只包含数字,返回True,否则为False\n\n```python\nstr1 = 'asd123 321asd'\nprint(str1.isspace())#如果str1中只包含空格则返回true 否则false\nprint(str1.isalnum())#如果都是字母或数字则返回true,否则false\n```\n    False\n    False\n\n## isdigit & isalpha\n* 如果str1中只包含数字,返回True,否则为False\n* 如果str1中只包含字母,返回True,否则为False\n\n```python\nstr1 = 'asd123 321asd'\nprint(str1.isdigit())#如果都是数字则返回True否则false\nprint(str1.isalpha())#判断是否全是字母\n```\n    False\n    False\n\n\n\n[1]:http://leiy.live/2018/10/03/Python%E6%80%BB%E7%BB%93(1)/#more\n\n\n\n\n\n","tags":["Python"],"categories":["字符串处理"]},{"title":"Pandas总结","url":"/2019/03/13/pandas/","content":"# Pandas基本数据结构\n>pandas中主要的数据结构为Series和DataFrame,其中Series是一种类似于一维数据的对象,由一组数据以及与之相关的数据标签组成，仅由一组数据也是可以产生简单的Seriesd对象，注意:Series中的索引值也是可以重复的。DataFrame是一种表格型数据结构，包含一组有序的列，每列可以是不同的值类型(数值,字符串,布尔型)，DataFram有行索引也有列索引，可以看作是Series组成的字典。\n\n<br>\n<br>\n<br>\n\n\n# Series基本概述\n## Series创建\n### 使用列表创建Series\n```python\nser = pd.Series([1,2,3,4])\nser\n```\n    0    1\n    1    2\n    2    3\n    3    4\n    dtype: int64\n### 使用数组创建\n```python\nser = pd.Series(np.random.randint(1,9,5))\nser\n```\n    0    2\n    1    4\n    2    2\n    3    6\n    4    1\n    dtype: int64\n### 使用字典创建\n```python\ndic = {\n    'a' : 1,\n    'b' : 2,\n    'c' : 3\n}\nser = pd.Series(dic)\nser\n```\n    a    1\n    b    2\n    c    3\n    dtype: int64\n\n\n## Series的index和value\n```python\ndic = {\n    'a' : 1,\n    'b' : 2,\n    'c' : 3\n}\nser = pd.Series(dic)\nprint(ser)\nprint('-'*50)\nprint(ser.index)\nprint(ser.values)\n```\n    a    1\n    b    2\n    c    3\n    dtype: int64\n    --------------------------------------------------\n    Index(['a', 'b', 'c'], dtype='object')\n    [1 2 3]\n\n## 修改和指定index\n```python\n# 修改index\narr = pd.Series(np.random.randint(1,9,5))\nprint(arr)\nprint('---------------index修改后---------------------')\narr.index = list('abcde')\nprint(arr)\n```\n    0    6\n    1    4\n    2    7\n    3    2\n    4    1\n    dtype: int64\n    ---------------index修改后---------------------\n    a    6\n    b    4\n    c    7\n    d    2\n    e    1\n    dtype: int64\n\n```python\n# 创建时指定index\narr = pd.Series(np.random.randint(1,9,5),index = ['a','b','c','d','e'])\narr\n```\n    a    4\n    b    3\n    c    8\n    d    4\n    e    7\n    dtype: int64\n\n\n## 常见属性\n```python\nser = pd.Series(np.random.randint(1,9,5),index = ['a','b','c','d','e'])\nprint(ser)\nprint('---------------增加一个index-----------------------')\nser.name = 'Leiy' # 如果不存在name自动创建 如果存在这一步就是改变name对应的value \nprint(ser)\n\nprint('---------------常见Series属性-----------------------')\nprint('行轴标签数据列表为:',ser.axes)\nprint('对象的数据类型:',ser.dtype)\nprint('检测系列是否为空:',ser.empty)\nprint('底层数据的维度:',ser.ndim)\nprint('基层数据中的元素数目:',ser.size)\nprint('返回数据的前3行:',ser.head(3))\nprint('返回数据的后3行:',ser.tail(2))\n```\n\n    a    5\n    b    7\n    c    8\n    d    7\n    e    5\n    dtype: int64\n    ---------------增加一个index-----------------------\n    a    5\n    b    7\n    c    8\n    d    7\n    e    5\n    Name: Leiy, dtype: int64\n    ---------------常见Series属性-----------------------\n    行轴标签数据列表为: [Index(['a', 'b', 'c', 'd', 'e'], dtype='object')]\n    对象的数据类型: int64\n    检测系列是否为空: False\n    底层数据的维度: 1\n    基层数据中的元素数目: 5\n    返回数据的前3行: \n    a    5\n    b    7\n    c    8\n    Name: Leiy, dtype: int64\n    返回数据的后3行: \n    d    7\n    e    5\n    Name: Leiy, dtype: int64\n\n## 索引与切片\n```python\nser = pd.Series(np.random.randint(1,9,5),index = ['a','b','c','d','e'])\nprint(ser)\nprint('---------------索引-----------------------')\nprint(ser['a'])\nprint(ser[0]) # 数字下标索引\nprint(ser[['a','c']])\n\nprint('---------------切片-----------------------')\nprint(ser['a':'c'])\nprint(ser[0:3])\n```\n    a    1\n    b    4\n    c    1\n    d    7\n    e    5\n    dtype: int64\n    ---------------索引-----------------------\n    1\n    1\n    a    1\n    c    1\n    dtype: int64\n    ---------------切片-----------------------\n    a    1\n    b    4\n    c    1\n    dtype: int64\n    a    1\n    b    4\n    c    1\n    dtype: int64\n\n## Series运算\n```python\nser1 = pd.Series(np.random.randint(1,5,5))\nser2 = pd.Series(np.random.randint(1,5,5))\nprint(ser1)\nprint(ser2)\nprint('---------------Series与标量的运算-----------------------')\nprint(ser1 + 10)\nprint(ser1 - 10)\nprint(ser1 * 10)\nprint(ser1 / 10)\nprint(ser1 ** 2)\nprint('---------------Series与Series的运算--------------------')\nprint(ser1 + ser2)\nprint(ser1 - ser2)\nprint(ser1 * ser2)\nprint(ser1 / ser2)\nprint(ser1 ** ser2)\nprint('---------------Series的其他运算------------------------')\nprint(np.log(ser1))\nprint(np.exp(ser1))\nprint(ser < 2)\n```\n    0    1\n    1    2\n    2    3\n    3    2\n    4    3\n    dtype: int64\n    0    2\n    1    4\n    2    1\n    3    4\n    4    1\n    dtype: int64\n    ---------------Series与标量的运算-----------------------\n    0    11\n    1    12\n    2    13\n    3    12\n    4    13\n    dtype: int64\n    0   -9\n    1   -8\n    2   -7\n    3   -8\n    4   -7\n    dtype: int64\n    0    10\n    1    20\n    2    30\n    3    20\n    4    30\n    dtype: int64\n    0    0.1\n    1    0.2\n    2    0.3\n    3    0.2\n    4    0.3\n    dtype: float64\n    0    1\n    1    4\n    2    9\n    3    4\n    4    9\n    dtype: int64\n    ---------------Series与Series的运算--------------------\n    0    3\n    1    6\n    2    4\n    3    6\n    4    4\n    dtype: int64\n    0   -1\n    1   -2\n    2    2\n    3   -2\n    4    2\n    dtype: int64\n    0    2\n    1    8\n    2    3\n    3    8\n    4    3\n    dtype: int64\n    0    0.5\n    1    0.5\n    2    3.0\n    3    0.5\n    4    3.0\n    dtype: float64\n    0     1\n    1    16\n    2     3\n    3    16\n    4     3\n    dtype: int64\n    ---------------Series的其他运算------------------------\n    0    0.000000\n    1    0.693147\n    2    1.098612\n    3    0.693147\n    4    1.098612\n    dtype: float64\n    0     2.718282\n    1     7.389056\n    2    20.085537\n    3     7.389056\n    4    20.085537\n    dtype: float64\n    0     True\n    1    False\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n## Series自动对齐、缺失值过滤\n```python\nser01 = pd.Series(np.random.randint(1,5,5), index = list('abcde'))\nser02 = pd.Series(np.random.randint(1,5,5), index = list('abmne'))\nprint(ser01)\nprint(ser02)\nprint('---------------Series自动对齐-----------------------')\nmask = ser01 + ser02\nprint(mask)\nprint('---------------Series缺失值过滤---------------------')\nprint(np.isnan(mask))\nprint(mask[~np.isnan(mask)]) #或者 print(mask[mask.notnull()])\n```\n    a    2\n    b    2\n    c    2\n    d    4\n    e    3\n    dtype: int64\n    a    4\n    b    3\n    m    4\n    n    3\n    e    3\n    dtype: int64\n    ---------------Series自动对齐-----------------------\n    a    6.0\n    b    5.0\n    c    NaN\n    d    NaN\n    e    6.0\n    m    NaN\n    n    NaN\n    dtype: float64\n    ---------------Series缺失值过滤---------------------\n    a    False\n    b    False\n    c     True\n    d     True\n    e    False\n    m     True\n    n     True\n    dtype: bool\n    a    6.0\n    b    5.0\n    e    6.0\n    dtype: float64\n\n<br>\n<br>\n<br>\n\n\n# DataFrame概述\n## DataFrame创建 & 重置索引\n### 使用列表创建\n```python\nlist1 = [[1,2,3,4],[5,6,7,8]]\ndf01 = pd.DataFrame(list1)\nprint(df01.index) # df01的横向索引\nprint(df01.columns) # df01的纵向索引\nprint(df01.values) # df01的值 \nprint('-'*50)\nprint(df01)\n```\n    RangeIndex(start=0, stop=2, step=1)\n    RangeIndex(start=0, stop=4, step=1)\n    [[1 2 3 4]\n    [5 6 7 8]]\n    --------------------------------------------------\n       0  1  2  3\n    0  1  2  3  4\n    1  5  6  7  8\n### 使用series创建\n```python\nser01 = pd.Series([1,2,3,4])\nser02 = pd.Series([5,6,7,8])\ndf = pd.DataFrame([ser01,ser02])\ndf\n```\n       0  1  2  3\n    0  1  2  3  4\n    1  5  6  7  8\n\n### 使用数组创建\n```python\narr = np.random.randint(1,9,(3,3))\ndf = pd.DataFrame(arr)\ndf\n```\n       0  1  2\n    0  1  3  4\n    1  3  3  2\n    2  3  1  6\n\n### 使用字典创建\n```python\ndic = {\n    'name':['joe','anne','yilianna'],\n    'age' : [18,19,20],\n    'class' : 1 #整列数据可以标量填充\n}\ndf = pd.DataFrame(dic)\ndf\n```\n           name  age  class\n    0       joe   18      1\n    1      anne   19      1\n    2  yilianna   20      1\n\n\n### 重置索引\n```python\ndic = {\n    'name':['joe','anne','yilianna'],\n    'age' : [18,19,20],\n    'class' : 1 #整列数据可以标量填充\n}\ndf = pd.DataFrame(dic)\nprint(df)\nprint('-'*50)\ndf.index = list('abc') #修改横向索引\nprint(df)\nprint('-'*50)\ndf.columns = list('ABC') #修改纵向索引\nprint(df)\n```\n           name  age  class\n    0       joe   18      1\n    1      anne   19      1\n    2  yilianna   20      1\n    --------------------------------------------------\n           name  age  class\n    a       joe   18      1\n    b      anne   19      1\n    c  yilianna   20      1\n    --------------------------------------------------\n              A   B  C\n    a       joe  18  1\n    b      anne  19  1\n    c  yilianna  20  1\n\n## 增删改查操作\n### 增删改查列操作\n```python\ndic = {\n    'name':['joe','anne','yilianna'],\n    'age' : [18,19,20],\n    'class' : 1 #整列数据可以标量填充\n}\ndf = pd.DataFrame(dic)\nprint(df)\nprint('---------------列操作 查-----------------------------')\nprint(df['name'])\nprint(df[['name','age']]) #获取多列数据\nprint('---------------列操作 增-----------------------------')\ndf['address'] = ['usa','uk','cn']\nprint(df)\nprint('---------------列操作 删-----------------------------')\ndf.pop('address')\nprint(df)\nprint('---------------列操作 改-----------------------------')\ndf['class'] = [3,4,5]\nprint(df)\n```\n           name  age  class\n    0       joe   18      1\n    1      anne   19      1\n    2  yilianna   20      1\n    ---------------列操作 查-----------------------------\n    0         joe\n    1        anne\n    2    yilianna\n    Name: name, dtype: object\n           name  age\n    0       joe   18\n    1      anne   19\n    2  yilianna   20\n    ---------------列操作 增-----------------------------\n           name  age  class address\n    0       joe   18      1     usa\n    1      anne   19      1      uk\n    2  yilianna   20      1      cn\n    ---------------列操作 删-----------------------------\n           name  age  class\n    0       joe   18      1\n    1      anne   19      1\n    2  yilianna   20      1\n    ---------------列操作 改-----------------------------\n           name  age  class\n    0       joe   18      3\n    1      anne   19      4\n    2  yilianna   20      5\n\n### 增删改查行操作\n```python\ndic = {\n    'name':['joe','anne','yilianna'],\n    'age' : [18,19,20],\n    'class' : 1 #整列数据可以标量填充\n}\ndf = pd.DataFrame(dic)\nprint(df)\nprint('---------------行操作 查-----------------------------')\nprint(df.loc[0])\nprint(df.loc[[0,2]]) # 选择指定行\nprint('-'*20)\nprint(df.loc[0,'name']) # 选择某行某列\nprint(df.loc[[0,2],'name'])\nprint(df.loc[[0,2],['name','age']])\n\n\nprint('---------------行操作 切片---------------------------')\nprint(df.loc[1:,'name':'class'])\n\n\nprint('---------------数字索引方式获取-----------------------')\nprint(df.iloc[0])\nprint(df.iloc[[0,1],[0,1]])\n```\n\n           name  age  class\n    0       joe   18      1\n    1      anne   19      1\n    2  yilianna   20      1\n    ---------------行操作 查-----------------------------\n    name     joe\n    age       18\n    class      1\n    Name: 0, dtype: object\n           name  age  class\n    0       joe   18      1\n    2  yilianna   20      1\n    --------------------\n    joe\n    0         joe\n    2    yilianna\n    Name: name, dtype: object\n           name  age\n    0       joe   18\n    2  yilianna   20\n    ---------------行操作 切片---------------------------\n           name  age  class\n    1      anne   19      1\n    2  yilianna   20      1\n    ---------------数字索引方式获取-----------------------\n    name     joe\n    age       18\n    class      1\n    Name: 0, dtype: object\n       name  age\n    0   joe   18\n    1  anne   19\n\n```python\ndic = {\n    'name':['joe','anne','yilianna'],\n    'age' : [18,19,20],\n    'class' : 1 #整列数据可以标量填充\n}\ndf = pd.DataFrame(dic)\nprint(df)\nprint('---------------行操作 增-----------------------')\ndf.loc['3'] = ['ronaldo',16,1]\nprint(df)\n\nprint('---------------行操作 删-----------------------')\ndf = df.drop('3')\nprint(df)\n\nprint('---------------行操作 改-----------------------')\ndf.loc[2] = ['messi',19,9]\nprint(df)\n```\n\n           name  age  class\n    0       joe   18      1\n    1      anne   19      1\n    2  yilianna   20      1\n    ---------------行操作 增-----------------------\n           name  age  class\n    0       joe   18      1\n    1      anne   19      1\n    2  yilianna   20      1\n    3   ronaldo   16      1\n    ---------------行操作 删-----------------------\n           name  age  class\n    0       joe   18      1\n    1      anne   19      1\n    2  yilianna   20      1\n    ---------------行操作 改-----------------------\n        name  age  class\n    0    joe   18      1\n    1   anne   19      1\n    2  messi   19      9\n\n\n<br>\n<br>\n<br>\n\n\n\n# Pandas基本功能\n## 数据文件读取/文本数据读取与文本存储\n### 读取csv文件\n```python\ndata = pd.read_csv('data1.csv')\ndata\n```\n### 读取文本文件\n```python\ndata = pd.read_csv('data1.txt',sep = '::',engine = 'python') #这边需要自定义分割符\ndata\n```\n### 读取Excel文件\n```python\ndata = pd.read_excel('data1.xlsx')\ndata\n``` \n### 存储文件\n```python\ndata.to_csv('football.csv',index = False) # 这里的index需要列入 不然会多一列数据\n```\n\n\n## 缺失值处理\n```python\ndf = pd.DataFrame(np.random.randint(1,9,(4,4)),index = list('ABCD'),columns = list('abcd'))\ndf.loc['B','c'] = np.NaN\ndf.loc['C','b'] = np.NaN\nprint(df)\nprint('---------------判断是否残缺数据-----------------------')\nprint(df[:].isnull())\n\nprint('---------------删除带有NaN的行数据--------------------')\nprint(df.dropna()) #默认删除带有NaN的行，只要含有一个就整行删除\n\nprint('---------------删除带有NaN的列数据--------------------')\nprint(df.dropna(axis = 1))\n\nprint('---------------自定义删除的数据的阀值------------------')\ndf.loc['E'] = np.NaN\nprint(df)\nprint(df.dropna(how = 'all')) # 只是删除整行为nan的数据\n\nprint('---------------filla处理----------------------------')\ndf.loc['E'] = np.NaN\ndf = df.fillna(0) # 将整行NaN数据替换为0\nprint(df)\n\nprint('---------------根据前一个值替换-----------------------')\ndf.loc['B','c'] = np.NaN\ndf.loc['C','b'] = np.NaN\nprint(df)\nprint('-'*20)\ndf = df.fillna(method = 'ffill') \nprint(df)\n\nprint('---------------根据后一个值替换-----------------------')\ndf.loc['B','c'] = np.NaN\ndf.loc['C','b'] = np.NaN\nprint(df)\nprint('-'*20)\ndf = df.fillna(method = 'bfill') \nprint(df)\n\nprint('---------------根据列进行替换------------------------')\ndf.loc['B','c'] = np.NaN\ndf.loc['C','b'] = np.NaN\nprint(df)\nprint('-'*20)\ndf = df01.fillna({'b':100,'c':200})\nprint(df)\n```\n       a    b    c  d\n    A  6  3.0  2.0  3\n    B  1  8.0  NaN  2\n    C  8  NaN  6.0  8\n    D  7  7.0  1.0  6\n    ---------------判断是否残缺数据-----------------------\n        a      b      c      d\n    A  False  False  False  False\n    B  False  False   True  False\n    C  False   True  False  False\n    D  False  False  False  False\n    ---------------删除带有NaN的行数据--------------------\n       a    b    c  d\n    A  6  3.0  2.0  3\n    D  7  7.0  1.0  6\n    ---------------删除带有NaN的列数据--------------------\n    a  d\n    A  6  3\n    B  1  2\n    C  8  8\n    D  7  6\n    ---------------自定义删除的数据的阀值------------------\n        a    b    c    d\n    A  6.0  3.0  2.0  3.0\n    B  1.0  8.0  NaN  2.0\n    C  8.0  NaN  6.0  8.0\n    D  7.0  7.0  1.0  6.0\n    E  NaN  NaN  NaN  NaN\n        a    b    c    d\n    A  6.0  3.0  2.0  3.0\n    B  1.0  8.0  NaN  2.0\n    C  8.0  NaN  6.0  8.0\n    D  7.0  7.0  1.0  6.0\n    ---------------filla处理----------------------------\n        a    b    c    d\n    A  6.0  3.0  2.0  3.0\n    B  1.0  8.0  0.0  2.0\n    C  8.0  0.0  6.0  8.0\n    D  7.0  7.0  1.0  6.0\n    E  0.0  0.0  0.0  0.0\n    ---------------根据前一个值替换-----------------------\n        a    b    c    d\n    A  6.0  3.0  2.0  3.0\n    B  1.0  8.0  NaN  2.0\n    C  8.0  NaN  6.0  8.0\n    D  7.0  7.0  1.0  6.0\n    E  0.0  0.0  0.0  0.0\n    --------------------\n        a    b    c    d\n    A  6.0  3.0  2.0  3.0\n    B  1.0  8.0  2.0  2.0\n    C  8.0  8.0  6.0  8.0\n    D  7.0  7.0  1.0  6.0\n    E  0.0  0.0  0.0  0.0\n    ---------------根据后一个值替换-----------------------\n        a    b    c    d\n    A  6.0  3.0  2.0  3.0\n    B  1.0  8.0  NaN  2.0\n    C  8.0  NaN  6.0  8.0\n    D  7.0  7.0  1.0  6.0\n    E  0.0  0.0  0.0  0.0\n    --------------------\n        a    b    c    d\n    A  6.0  3.0  2.0  3.0\n    B  1.0  8.0  6.0  2.0\n    C  8.0  7.0  6.0  8.0\n    D  7.0  7.0  1.0  6.0\n    E  0.0  0.0  0.0  0.0\n    ---------------根据列进行替换------------------------\n        a    b    c    d\n    A  6.0  3.0  2.0  3.0\n    B  1.0  8.0  NaN  2.0\n    C  8.0  NaN  6.0  8.0\n    D  7.0  7.0  1.0  6.0\n    E  0.0  0.0  0.0  0.0\n    --------------------\n       a      b      c  d\n    A  6    6.0    8.0  1\n    B  1    2.0  200.0  2\n    C  1  100.0    7.0  1\n    D  6    7.0    2.0  5\n\n\n## 常用统计函数\n```python\ndf = pd.DataFrame(np.random.randint(1,9,(4,4)),index = list('ABCD'),columns = list('abcd'))\nprint(df)\nprint('---------------count函数------------------------')\nprint(df.count()) #统计非nan的数值\n\nprint('---------------describe函数---------------------')\nprint(df.describe())\n\nprint('---------------min函数--------------------------')\nprint(df.min())\n\nprint('---------------idmin函数------------------------')\nprint(df.idxmin()) #最小的在那一行\n\nprint('---------------sum函数--------------------------')\nprint(df.sum())\n\nprint('---------------mad函数--------------------------')\nprint(df.mad()) #根据平均值计算平均绝对距离差\n\nprint('---------------cumsum函数-----------------------')\nprint(df.cumsum())\n\nprint('---------------pct_change函数-------------------')\nprint(df.pct_change()) # 计算百分比函数\n```\n       a  b  c  d\n    A  4  3  3  4\n    B  5  7  3  8\n    C  4  8  7  5\n    D  4  6  1  4\n    ---------------count函数------------------------\n    a    4\n    b    4\n    c    4\n    d    4\n    dtype: int64\n    ---------------describe函数---------------------\n            a         b         c         d\n    count  4.00  4.000000  4.000000  4.000000\n    mean   4.25  6.000000  3.500000  5.250000\n    std    0.50  2.160247  2.516611  1.892969\n    min    4.00  3.000000  1.000000  4.000000\n    25%    4.00  5.250000  2.500000  4.000000\n    50%    4.00  6.500000  3.000000  4.500000\n    75%    4.25  7.250000  4.000000  5.750000\n    max    5.00  8.000000  7.000000  8.000000\n    ---------------min函数--------------------------\n    a    4\n    b    3\n    c    1\n    d    4\n    dtype: int64\n    ---------------idmin函数------------------------\n    a    A\n    b    A\n    c    D\n    d    A\n    dtype: object\n    ---------------sum函数--------------------------\n    a    17\n    b    24\n    c    14\n    d    21\n    dtype: int64\n    ---------------mad函数--------------------------\n    a    0.375\n    b    1.500\n    c    1.750\n    d    1.375\n    dtype: float64\n    ---------------cumsum函数-----------------------\n        a   b   c   d\n    A   4   3   3   4\n    B   9  10   6  12\n    C  13  18  13  17\n    D  17  24  14  21\n    ---------------pct_change函数-------------------\n        a         b         c      d\n    A   NaN       NaN       NaN    NaN\n    B  0.25  1.333333  0.000000  1.000\n    C -0.20  0.142857  1.333333 -0.375\n    D  0.00 -0.250000 -0.857143 -0.200\n\n## 相关系数和协方差\n```python\n# 如果协方差为正,说明X,Y同向变化,协方差越大说明同向程度越高;如果协方差\n# 为负,说明X,Y反向运动,协方差越小说明反向程度越高。\ndf = pd.DataFrame({\n    'kill' : [5,6,7,8],\n    'duanwei' : [1,2,3,4]   \n})\ndf['kill'].cov(df['duanwei'])\n```\n    1.6666666666666665\n\n## 唯一值，值计数，成员资格\n```python\nser = pd.Series(np.random.randint(1,5,6),index = list('abcedf'))\nprint(ser)\nprint('---------------唯一值---------------------------')\nprint(ser.unique()) #唯一值\n\nprint('---------------各个值出现的次数-------------------')\nprint(ser.value_counts())\n\nprint('---------------某个值是否出现---------------------')\nprint(ser.isin([2,3]))\n\nprint('---------------某个索引是否出现-------------------')\nprint(ser.index.isin(['a']))\n\nprint('---------------一些应用--------------------------')\ndf = pd.DataFrame({\n    'movie_name' : list('abadcebe'),\n    'rating' : [4,5,3,5,3,4,3,5]\n})\nprint(df)\nprint('-'*20)\nprint(df['movie_name'].unique())\nprint('-'*20)\nprint(df['movie_name'].value_counts().head(3))\nprint('-'*20)\nprint(df['movie_name'].isin(['a','b']))\n```\n    a    1\n    b    2\n    c    1\n    e    2\n    d    3\n    f    2\n    dtype: int64\n    ---------------唯一值---------------------------\n    [1 2 3]\n    ---------------各个值出现的次数-------------------\n    2    3\n    1    2\n    3    1\n    dtype: int64\n    ---------------某个值是否出现---------------------\n    a    False\n    b     True\n    c    False\n    e     True\n    d     True\n    f     True\n    dtype: bool\n    ---------------某个索引是否出现-------------------\n    [ True False False False False False]\n    ---------------一些应用--------------------------\n    movie_name  rating\n    0          a       4\n    1          b       5\n    2          a       3\n    3          d       5\n    4          c       3\n    5          e       4\n    6          b       3\n    7          e       5\n    --------------------\n    ['a' 'b' 'd' 'c' 'e']\n    --------------------\n    a    2\n    b    2\n    e    2\n    Name: movie_name, dtype: int64\n    --------------------\n    0     True\n    1     True\n    2     True\n    3    False\n    4    False\n    5    False\n    6     True\n    7    False\n    Name: movie_name, dtype: bool\n\n\n\n## 层次索引\n```python\nser = pd.Series([30,33,35,18,20,30],index = [\n    [2017,2017,2017,2018,2018,2018],\n    ['messi','cr7','nermaer','messi','cr7','nermaer']\n])\nprint(ser)\n\nprint('---------------索引--------------------------')\nprint(ser[2017]['messi'])\nprint('-'*20)\nprint(ser[:,'messi'])\n\nprint('---------------交换层次-----------------------')\nser = ser.swaplevel().sort_index()\nprint(ser)\n\nprint('---------------转换为DataFrame---------------')\nser = ser.unstack(level = 1)\nprint(ser)\n```\n    2017  messi      30\n          cr7        33\n          nermaer    35\n    2018  messi      18\n          cr7        20\n          nermaer    30\n    dtype: int64\n    ---------------索引--------------------------\n    30\n    --------------------\n    2017    30\n    2018    18\n    dtype: int64\n    ---------------交换层次-----------------------\n    cr7      2017    33\n             2018    20\n    messi    2017    30\n             2018    18\n    nermaer  2017    35\n             2018    30\n    dtype: int64\n    ---------------转换为DataFrame---------------\n            2017  2018\n    cr7       33    20\n    messi     30    18\n    nermaer   35    30\n\n```python\n'''\n    dataframe\n'''\ndf = pd.DataFrame({\n    'year' : [2017,2017,2017,2018,2018,2018],\n    'goal' : [30,30,31,28,29,30],\n    'name' : ['messi','cr7','nermaer','messi','cr7','nermaer']\n})\nprint(df)\n\nprint('---------------set_index函数---------------')\ndf = df.set_index(['year','name'])\nprint(df)\n\nprint('---------------索引------------------------')  \nprint(df.loc[2017,'messi'])\nprint('-'*20)\nprint(df.loc[2017])\n\nprint('---------------unstack/stack函数-----------')\nprint(df.unstack())\nprint('-'*20)\nprint(df.stack())\n\nprint('---------------求和函数---------------------')\nprint(df.sum(level = 'year'))\nprint('-'*20)\nprint(df.sum(level = 'name'))\n```\n       year  goal     name\n    0  2017    30    messi\n    1  2017    30      cr7\n    2  2017    31  nermaer\n    3  2018    28    messi\n    4  2018    29      cr7\n    5  2018    30  nermaer\n    ---------------set_index函数---------------\n                  goal\n    year name         \n    2017 messi      30\n         cr7        30\n         nermaer    31\n    2018 messi      28\n         cr7        29\n         nermaer    30\n    ---------------索引------------------------\n    goal    30\n    Name: (2017, messi), dtype: int64\n    --------------------\n            goal\n    name         \n    messi      30\n    cr7        30\n    nermaer    31\n    ---------------unstack/stack函数-----------\n        goal              \n    name  cr7 messi nermaer\n    year                   \n    2017   30    30      31\n    2018   29    28      30\n    --------------------\n    year  name         \n    2017  messi    goal    30\n          cr7      goal    30\n          nermaer  goal    31\n    2018  messi    goal    28\n          cr7      goal    29\n          nermaer  goal    30\n    dtype: int64\n    ---------------求和函数---------------------\n        goal\n    year      \n    2017    91\n    2018    87\n    --------------------\n            goal\n    name         \n    messi      58\n    cr7        59\n    nermaer    61\n\n\n## 排序\n### sort_index/sort_values排序\n```python\nser = pd.Series([1,2,3,4,5],index = list('bdcae'))\ndf = pd.DataFrame(np.random.randint(1,9,(4,4)),index = list('BDCA'),columns = list('cadb'))\nprint(ser)\nprint('---------------sort_index排序---------------------')\nprint(ser.sort_index(ascending = True))\nprint('-'*20)\nprint(df.sort_index(axis = 1))\n\nprint('---------------sort_values排序--------------------')\nprint(ser.sort_values(ascending = False))\nprint('-'*20)\nprint(df.sort_values(by = 'c',ascending = False))\n```\n    b    1\n    d    2\n    c    3\n    a    4\n    e    5\n    dtype: int64\n    ---------------sort_index排序---------------------\n    a    4\n    b    1\n    c    3\n    d    2\n    e    5\n    dtype: int64\n    --------------------\n       a  b  c  d\n    B  1  6  8  8\n    D  7  7  5  3\n    C  7  7  6  5\n    A  7  4  4  2\n    ---------------sort_values排序--------------------\n    e    5\n    a    4\n    c    3\n    d    2\n    b    1\n    dtype: int64\n    --------------------\n       c  a  d  b\n    B  8  1  8  6\n    C  6  7  5  7\n    D  5  7  3  7\n    A  4  7  2  4\n\n\n### rank排序\n```python\nser = pd.Series([4,5,2,2,1],index = list('bdcae'))\ndf = pd.DataFrame(np.random.randint(1,9,(4,4)),index = list('BDCA'),columns = list('cadb'))\nprint(ser)\nprint('---------------rank排序---------------------')\nprint(ser.rank())\nprint('-'*20)\nprint(ser.rank(method = 'min'))\nprint('-'*20)\nprint(ser.rank(method = 'max'))\nprint('-'*20)\nprint(ser.rank(method = 'first'))\n```\n    b    4\n    d    5\n    c    2\n    a    2\n    e    1\n    dtype: int64\n    ---------------rank排序---------------------\n    b    4.0\n    d    5.0\n    c    2.5\n    a    2.5\n    e    1.0\n    dtype: float64\n    --------------------\n    b    4.0\n    d    5.0\n    c    2.0\n    a    2.0\n    e    1.0\n    dtype: float64\n    --------------------\n    b    4.0\n    d    5.0\n    c    3.0\n    a    3.0\n    e    1.0\n    dtype: float64\n    --------------------\n    b    4.0\n    d    5.0\n    c    2.0\n    a    3.0\n    e    1.0\n    dtype: float64\n\n\n## 时间序列\n```python\nprint(pd.date_range(start = '20180701',end = '20180708',freq = '2d')) # freq默认为一天\nprint('-'*50)\nprint(pd.date_range(start = '20180701',periods = 10, freq = '10min')) # 设定显示条数\n```\n    DatetimeIndex(['2018-07-01', '2018-07-03', '2018-07-05', '2018-07-07'], dtype='datetime64[ns]', freq='2D')\n    --------------------------------------------------\n    DatetimeIndex(['2018-07-01 00:00:00', '2018-07-01 00:10:00',\n                '2018-07-01 00:20:00', '2018-07-01 00:30:00',\n                '2018-07-01 00:40:00', '2018-07-01 00:50:00',\n                '2018-07-01 01:00:00', '2018-07-01 01:10:00',\n                '2018-07-01 01:20:00', '2018-07-01 01:30:00'],\n                dtype='datetime64[ns]', freq='10T')\n\n## 数据合并\n```python\ndf01 = pd.DataFrame({\n    'data1' : [1,2,3,4,5],\n    'key'  : list('abcde')\n})\ndf02 = pd.DataFrame({\n    'data2' : [1,2,3,4,5],\n    'key' : list('abcde')\n})\nprint(df01)\nprint(df02)\nprint('---------------merge合并---------------------')\nprint(pd.merge(df01,df02,on = 'key',how = 'inner')) # inner的意思是说相同的key进行整和\n```\n       data1 key\n    0      1   a\n    1      2   b\n    2      3   c\n    3      4   d\n    4      5   e\n       data2 key\n    0      1   a\n    1      2   b\n    2      3   c\n    3      4   d\n    4      5   e\n    ---------------merge合并---------------------\n       data1 key  data2\n    0      1   a      1\n    1      2   b      2\n    2      3   c      3\n    3      4   d      4\n    4      5   e      5\n\n```python\ndf01 = pd.DataFrame({\n    'data1' : [1,2,3,4,5],\n    'key'  : list('abcde')\n})\ndf02 = pd.DataFrame({\n    'data2' : [1,2,3,4,5],\n    'key' : list('abcfg')\n})\nprint(df01)\nprint(df02)\nprint('---------------merge合并---------------------')\nprint(pd.merge(df01,df02,on = 'key',how = 'inner'))\nprint('-'*20)\n\nprint(pd.merge(df01,df02,on = 'key',how = 'left'))\nprint('-'*20)\n\nprint(pd.merge(df01,df02,on = 'key',how = 'right'))\n```\n       data1 key\n    0      1   a\n    1      2   b\n    2      3   c\n    3      4   d\n    4      5   e\n       data2 key\n    0      1   a\n    1      2   b\n    2      3   c\n    3      4   f\n    4      5   g\n    ---------------merge合并---------------------\n       data1 key  data2\n    0      1   a      1\n    1      2   b      2\n    2      3   c      3\n    --------------------\n       data1 key  data2\n    0      1   a    1.0\n    1      2   b    2.0\n    2      3   c    3.0\n    3      4   d    NaN\n    4      5   e    NaN\n    --------------------\n       data1 key  data2\n    0    1.0   a      1\n    1    2.0   b      2\n    2    3.0   c      3\n    3    NaN   f      4\n    4    NaN   g      5\n```python\ndf01 = pd.DataFrame({\n    'data1' : [1,2,3,4,5],\n    'key1'  : list('abcde')\n})\ndf02 = pd.DataFrame({\n    'data2' : [1,2,3,4,5],\n    'key2' : list('abcfg')\n})\nprint(df01)\nprint(df02)\nprint('---------------merge合并---------------------')\nprint(pd.merge(df01,df02,left_on = 'key1',right_on = 'key2',how = 'inner'))\nprint('-'*20)\n\nprint(pd.merge(df01,df02,left_on = 'key1',right_on = 'key2',how = 'left'))\n\n```\n       data1 key1\n    0      1    a\n    1      2    b\n    2      3    c\n    3      4    d\n    4      5    e\n       data2 key2\n    0      1    a\n    1      2    b\n    2      3    c\n    3      4    f\n    4      5    g\n    ---------------merge合并---------------------\n       data1 key1  data2 key2\n    0      1    a      1    a\n    1      2    b      2    b\n    2      3    c      3    c\n    --------------------\n       data1 key1  data2 key2\n    0      1    a    1.0    a\n    1      2    b    2.0    b\n    2      3    c    3.0    c\n    3      4    d    NaN  NaN\n    4      5    e    NaN  NaN\n```python\ndf01 = pd.DataFrame({\n    'data1' : [1,2,3,4,5],\n    'key'  : list('abcde')\n})\ndf02 = pd.DataFrame({\n    'data2' : [1,2,3,4,5],\n    'key' : list('abcfg')\n})\nprint(df01)\nprint(df02)\nprint('---------------contact合并---------------------')\nprint(pd.concat([df01,df02],join = 'outer')) #纵向合并\nprint('-'*20)\nprint(pd.concat([df01,df02],axis = 1,join = 'outer'))\n```\n       data1 key\n    0      1   a\n    1      2   b\n    2      3   c\n    3      4   d\n    4      5   e\n       data2 key\n    0      1   a\n    1      2   b\n    2      3   c\n    3      4   f\n    4      5   g\n    ---------------contact合并---------------------\n       data1  data2 key\n    0    1.0    NaN   a\n    1    2.0    NaN   b\n    2    3.0    NaN   c\n    3    4.0    NaN   d\n    4    5.0    NaN   e\n    0    NaN    1.0   a\n    1    NaN    2.0   b\n    2    NaN    3.0   c\n    3    NaN    4.0   f\n    4    NaN    5.0   g\n    --------------------\n       data1 key  data2 key\n    0      1   a      1   a\n    1      2   b      2   b\n    2      3   c      3   c\n    3      4   d      4   f\n    4      5   e      5   g\n\n## 分组聚合\n分组聚合是分组+聚合，即先分组，分完组后再聚合\n```python\ndf = pd.DataFrame({\n    'data1' : [1,2,3,4,5],\n    'data2' : [10,20,30,40,50],\n    'key1' : list('aabba'),\n    'sex'  : list('mwmwm')\n})\nprint(df)\n\nprint('---------------分组并查看其内容---------------------')\nfor i in df.groupby('key1'):\n    print(i)\n    \nprint('---------------聚合函数----------------------------')\nprint(df.groupby('key1')['data1'].mean())\nprint('-'*20)\nprint(df.groupby('key1')['data1'].max())\n\n\nprint('--------------apply函数---------------------------')\nprint(df.groupby(['key1','sex'])['data1'].apply(lambda x: x+ 10))\nprint('-'*20)\nprint(df.groupby(['key1','sex'])['data1'].apply(lambda x: x.max()))\n\nprint('--------------apply函数应用示例---------------------')\ndf = pd.DataFrame(np.random.randint(1,9,(4,4)), index = list('ABCD'),columns = list('abcd'))\nprint(df)\nprint(df.apply(lambda x:x + 10))\nprint('-'*20)\n\n\ndef f1(x):\n    return x * 10\n\nprint(df.apply(f1))\n```\n       data1  data2 key1 sex\n    0      1     10    a   m\n    1      2     20    a   w\n    2      3     30    b   m\n    3      4     40    b   w\n    4      5     50    a   m\n    ---------------分组并查看其内容---------------------\n    ('a',    data1  data2 key1 sex\n    0      1     10    a   m\n    1      2     20    a   w\n    4      5     50    a   m)\n    ('b',    data1  data2 key1 sex\n    2      3     30    b   m\n    3      4     40    b   w)\n    ---------------聚合函数----------------------------\n    key1\n    a    2.666667\n    b    3.500000\n    Name: data1, dtype: float64\n    --------------------\n    key1\n    a    5\n    b    4\n    Name: data1, dtype: int64\n    --------------apply函数---------------------------\n    0    11\n    1    12\n    2    13\n    3    14\n    4    15\n    Name: data1, dtype: int64\n    --------------------\n    key1  sex\n    a     m      5\n          w      2\n    b     m      3\n          w      4\n    Name: data1, dtype: int64\n    --------------apply函数应用示例---------------------\n    a  b  c  d\n    A  3  1  2  8\n    B  6  1  6  1\n    C  8  8  2  8\n    D  7  2  2  4\n        a   b   c   d\n    A  13  11  12  18\n    B  16  11  16  11\n    C  18  18  12  18\n    D  17  12  12  14\n    --------------------\n        a   b   c   d\n    A  30  10  20  80\n    B  60  10  60  10\n    C  80  80  20  80\n    D  70  20  20  40\n\n\n\n\n\n","tags":["Pandas"],"categories":["Pandas总结"]},{"title":"Python入门之基本语法和数据类型","url":"/2019/03/13/Python总结(1)/","content":"# 注释\n* 单行注释使用 “#” 开头\n* 多行注释使用 ‘’‘注释内容’‘’\n\n\n# 变量\n* 变量命名规则采用驼峰命名法,驼峰命名法分为大驼峰(UserName)和小驼峰(userName)\n\n\n# 数据类型\n\n## Number\nint(整数)\nfloat(浮点数)\ncomplex(复数)\nbool(布尔)\n\n\n## String(字符串))\n* 在pyton中字符串采用单引号或者双引号，同时可以使用反斜杠 (\\) 表示转义特殊字符\n\n\n### 字符串索引和切片\n\n```python\nstr1 = 'abcdefg'\nprint(str1[0])\nprint(str1[0:2]) #左闭右开\nprint(str1[-1:-4:-1]) #第三个参数表示步长\nprint(type(str1[0]))\n```\n\n    a\n    ab\n    gfe\n    <class 'str'>\n\n### 字符串的加法和乘法\n```python\nstr1 = '---'\nstr2 = '***'\nprint(str1 + str2)\nprint(str2*5)\n```\n    ---***\n    ***************\n\n\n## List(列表)\n* 列表使用方括号中间元素用逗号隔开\n\n### 列表的索引和切片\n```python\nlist1 = ['你好','Leiy','Syy']\nprint(list1[:])\nprint(list1[0:2])\nprint(type(list1))\nprint(type(list1[0]))\n```\n    ['你好', 'Leiy', 'Syy']\n    ['你好', 'Leiy']\n    <class 'list'>\n    <class 'str'>\n\n### 列表拼接\n```python\nlist1 = ['你好']\nlist2 = ['苏大']\nprint(list1+list2)\n```\n    ['你好', '苏大']\n\n### 修改列表元素\n```python\nlist1 = ['你好','abcd',123]\n# list1[1][1] = 'a'  #error 字符串可以被索引但是没法子修改\nlist1[0] = 'a'\nprint(list1)\n```\n    ['a', 'abcd', 123]\n\n\n## Tuple(元祖)\n* 元祖使用小括号中间元素用逗号隔开\n* tuple的元素不可以改变但是可以包含可以改变的对象如list\n\n### 元祖索引\n```python\ntuple1 = ('abc', '你好', 123, [1, 2, 3, 4])\nprint(tuple1)       # 打印整个元祖数据\nprint(tuple1[0:2])  # 打印第二个元祖数据\n\ntuple1[3][0] = 4    # 修改元祖第3个数据的第一个数据 元祖虽然不可变但列表可变\nprint(tuple1)       # 打印修改后的元祖\n```\n    ('abc', '你好', 123, [1, 2, 3, 4])\n    ('abc', '你好')\n    ('abc', '你好', 123, [4, 2, 3, 4])\n\n## Dictionary(字典)\n* 字典是一种映射类型,使用{}\n* 键值key必须使用不可边类型(字符串,数值,元祖),同一个字典中,键必须是唯一的\n* 创建空字典用{}\n\n### 字典的索引\n```python\ndict1 = {'name':'Leiy','age':17,'sex':'man'}\nprint(dict1)\ndict2 = {'name':'Leiy','age':17,'sex':'man','name':'syy'} #同一个字典产生了两个name 后面一个name覆盖了前面\nprint(dict2)\n\n\nprint(dict2['name'])#这边是索引dict1的name值\n\n\ndict3 = {'zhuang':{'age':17,'name':'Leiy'}}\nprint(dict3['zhuang'])        #字典索引\nprint(dict3['zhuang']['name'])#多层索引的获取\n```\n    {'name': 'Leiy', 'age': 17, 'sex': 'man'}\n    {'name': 'syy', 'age': 17, 'sex': 'man'}\n    syy\n    {'age': 17, 'name': 'Leiy'}\n    Leiy\n\n\n\n# 运算符\n## 算术运算符\n* 算术运算符有七种分别为\n+, -, *, /, %(取余)), **(幂)), //(取整)\n\n## 赋值运算符\n* 赋值运算符有八种分别为\n=, +=, -=, *=, /=, %=, **=, //=\n\n## 比较运算符\n* 比较运算符有六种\n==, ！=, >, <, >=, <=\n\n## 逻辑运算符\nand(布尔‘与’),or(布尔’或‘),not(布尔’非‘)\n## 位运算符\n&(按位与)\n|(按位或)\n^(按位异或)\n～(按位取反)\n<<(左移运算符)\n\\>>(右移运算符)\n\n\n\n\n\n\n","tags":["Python"],"categories":["基本语法和数据类型"]},{"title":"NumPy总结","url":"/2019/03/13/numpy/","content":"# ndarray(N-dimensional array)的创建\n## 通过列表创建\n```python\nlis1 = [1,2,3,4]\nlis2 = [\n    [1,2,3],\n    [4,5,6],\n    [7,8,9]\n]\nprint(np.array(lis1))\nprint(np.array(lis2))\nnp.array(lis1)\n```\n\n    [1 2 3 4]\n    [[1 2 3]\n    [4 5 6]\n    [7 8 9]]\n    array([1, 2, 3, 4])\n\n\n\n## 通过元祖创建\n```python\nls = (1,2,3,4)\nprint(np.array(ls))\nnp.array(ls)\n```\n\n    [1 2 3 4]\n    array([1, 2, 3, 4])\n\n\n## 通过元祖列表创建\n```python\nls = [(1,2,3,4),(5,6,7,8)]\nprint(np.array(ls))\nnp.array(ls)\n```\n\n    [[1 2 3 4]\n    [5 6 7 8]]\n    array([[1, 2, 3, 4],\n        [5, 6, 7, 8]])\n\n## 通过zeros,ones,empty,arange,linspace,logspace函数创建\n```python\nprint('------------------zeros------------------')\nprint(np.zeros(3))\nprint(np.zeros((3,3)))\n\nprint('-------------------ones------------------')\nprint(np.ones(5))\nprint(np.ones((3,3)))\n\nprint('------------------empty------------------')\nprint(np.empty(4))\nprint(np.empty((4,4)))\n\nprint('------------------arange-----------------')\nprint(np.arange(1,5))\nprint(np.arange(1,5,2))\n\nprint('-----------------linspace----------------')\nprint(np.linspace(1,10,5,endpoint = False)) #endpoint 不包含终值\n\nprint('-----------------logspace----------------')\nprint(np.logspace(1,2,10)) # 默认按照10为底数 base修改底数\n```\n\n    ------------------zeros------------------\n    [0. 0. 0.]\n    [[0. 0. 0.]\n    [0. 0. 0.]\n    [0. 0. 0.]]\n    -------------------ones------------------\n    [1. 1. 1. 1. 1.]\n    [[1. 1. 1.]\n    [1. 1. 1.]\n    [1. 1. 1.]]\n    ------------------empty------------------\n    [4.9e-324 9.9e-324 1.5e-323 2.0e-323]\n    [[2.48273508e-312 2.05833592e-312 2.05833592e-312 2.29175545e-312]\n    [2.07955588e-312 2.14321575e-312 5.98927459e+174 5.58294180e-322]\n    [6.91877543e-310 6.91877543e-310 6.48224638e+170 5.22411352e+257]\n    [5.74020278e+180 8.37174974e-144 1.41529402e+161 9.16651763e-072]]\n    ------------------arange-----------------\n    [1 2 3 4]\n    [1 3]\n    -----------------linspace----------------\n    [1.  2.8 4.6 6.4 8.2]\n    -----------------logspace----------------\n    [ 10.          12.91549665  16.68100537  21.5443469   27.82559402\n    35.93813664  46.41588834  59.94842503  77.42636827 100.        ]\n\n## 随机生成\n```python\nprint('----------------生成0~1之间的随机数----------------')\nprint(np.random.random(10)) #生成0~1之间的随机数\n\nprint('----------------生成二维--------------------------')\nprint(np.random.random((3,3))) #生成二维\n\n#生成平均分布的随机数\nprint('----------------生成平均分布的随机数----------------')\nprint(np.random.rand(10))\n\nprint('----------------生成二维--------------------------')\nprint(np.random.rand(3,3)) #生成二维\n\n\nprint('----------------生成正太分布的样本------------------')\n#生成正太分布的样本\nprint(np.random.randn(10))\nprint(np.random.randn(3,3))\n\nprint('----------------生成随机整数-----------------------')\n#生成随机整数\nprint(np.random.randint(1,9,10)) #start stop num\nprint(np.random.randint(1,9,(4,3,2)))\n```\n\n    ----------------生成0~1之间的随机数----------------\n    [0.41050443 0.33530101 0.12737482 0.3776622  0.19804841 0.06415537\n    0.60792785 0.59201645 0.63366439 0.7994575 ]\n    ----------------生成二维--------------------------\n    [[0.63610101 0.59998623 0.24031061]\n    [0.59947095 0.88685833 0.91053761]\n    [0.16609409 0.07818771 0.09755228]]\n    ----------------生成平均分布的随机数----------------\n    [0.45052764 0.33909482 0.49414278 0.91661282 0.39186027 0.76681922\n    0.28596852 0.47941687 0.67150723 0.97311004]\n    ----------------生成二维--------------------------\n    [[0.57140953 0.33062884 0.02135612]\n    [0.49340695 0.06304757 0.62082045]\n    [0.85733569 0.371159   0.95531718]]\n    ----------------生成正太分布的样本------------------\n    [ 0.4780681  -0.47782185 -0.87592782 -0.47986784  0.61341701 -1.46133798\n    0.02491327  0.89073992 -1.33471919  0.66143721]\n    [[ 1.21537403 -0.21829338 -2.46902817]\n    [-0.55565484 -0.52224036  0.66235131]\n    [-2.07846615  0.43426048  0.24828938]]\n    ----------------生成随机整数-----------------------\n    [5 2 4 5 1 8 4 4 7 7]\n    [[[7 8]\n    [8 7]\n    [5 3]]\n\n    [[1 4]\n    [8 6]\n    [1 4]]\n\n    [[6 6]\n    [4 2]\n    [1 2]]\n\n    [[7 4]\n    [4 7]\n    [8 3]]]\n\n\n\n\n<br>\n<br>\n<br>\n\n# ndarray对象属性,基本数据类型,reshape操作\n## ndarray对象属性\n```python\narr = np.random.randint(1,9,(3,3))\nprint(arr)\nprint('---------------------------')\nprint('ndim:',arr.ndim) #显示数组的轴 \nprint('shape:',arr.shape) #数组的形状\nprint('size:',arr.size) #元素的个数\nprint('dtype:',arr.dtype) #数据类型\nprint('itemsize:',arr.itemsize) #一个字节的位数\n```\n    [[2 2 8]\n    [7 8 8]\n    [2 4 6]]\n    ---------------------------\n    ndim: 2\n    shape: (3, 3)\n    size: 9\n    dtype: int64\n    itemsize: 8\n## ndarray基本数据类型\n```python\nlis = [1,2,3]\narr = np.array(lis)\nprint(arr)\nprint(arr.dtype)\nprint('-----------------------')\n\n\nlis = [1.1,2,3]\narr = np.array(lis)\nprint(arr)\nprint(arr.dtype)\nprint('-----------------------')\n\n#手动数据类型\nlis = [1,2,3]\narr = np.array(lis,dtype = np.float) #可以手动指定数据类型\nprint(arr)\nprint(arr.dtype)\nprint('-----------------------')\n\n\n#手动数据类型 简写模式\nlis = [1,2,3]\narr = np.array(lis,dtype = 'i1') #可以手动指定数据类型\nprint(arr)\nprint(arr.dtype)\nprint('-----------------------')\n\n\nlis = [1,2,3]\narr = np.array(lis,dtype = 'i1') #可以手动指定数据类型\nprint(arr)\nprint(arr.dtype)\narr = arr.astype('i8') # 类型转换\nprint(arr.dtype)\n```\n    [1 2 3]\n    int64\n    -----------------------\n    [1.1 2.  3. ]\n    float64\n    -----------------------\n    [1. 2. 3.]\n    float64\n    -----------------------\n    [1 2 3]\n    int8\n    -----------------------\n    [1 2 3]\n    int8\n    int64\n\n\n## reshape操作\n```python\narr = np.random.randint(1,9,(2,6))\nprint(arr)\nprint('arr数据维度',(arr.shape))\nprint('-----------------------------------')\n\n\narr = arr.reshape(4,3)\nprint(arr)\nprint('arr数据维度',(arr.shape))\nprint('-----------------------------------')\n\n\narr = arr.reshape(3,-1) # -1 系统自动推算\nprint(arr)\nprint('arr数据维度',(arr.shape))\n\n```\n    [[1 7 4 2 7 1]\n    [1 7 1 3 4 1]]\n    arr数据维度 (2, 6)\n    -----------------------------------\n    [[1 7 4]\n    [2 7 1]\n    [1 7 1]\n    [3 4 1]]\n    arr数据维度 (4, 3)\n    -----------------------------------\n    [[1 7 4 2]\n    [7 1 1 7]\n    [1 3 4 1]]\n    arr数据维度 (3, 4)\n\n<br>\n<br>\n<br>\n\n# numpy基本操作\n## 数组与标量、数组之间的运算\n```python\narr1 = np.array([1,2,3,4])\narr2 = np.array([2,3,4,5])\nprint('----------------数组和标量的运算---------------------')\nprint(arr + 10)\n\nprint('----------------数组和数组之间的运算------------------')\nprint(arr1 + arr2)\n```\n    ----------------数组和标量的运算---------------------\n    [11 12 13 14]\n    ----------------数组和数组之间的运算------------------\n    [3 5 7 9]\n\n\n\n## numpy中的广播功能\n不同维度的在某些情况(满足对应维度上的数量相同)下可以相加 这称为广播功能\n```python\narr1 = np.random.randint(1,9,(3,3))\narr2 = np.random.randint(1,9,(3,1))\nprint(arr1)\nprint('-'*50)\nprint(arr2)\nprint('-'*50)\nprint(arr1 + arr2)\n```\n    [[7 1 4]\n    [5 6 2]\n    [6 6 2]]\n    --------------------------------------------------\n    [[7]\n    [7]\n    [1]]\n    --------------------------------------------------\n    [[14  8 11]\n    [12 13  9]\n    [ 7  7  3]]\n\n## 数组的矩阵积\n```python\narr1 = np.random.randint(1,5,(3,3))\narr2 = np.random.randint(1,5,(3,2))\nprint(arr1)\nprint('-'*50)\nprint(arr2)\nprint('-'*50)\nprint(arr1.dot(arr2)) # 按照矩阵乘法规则\n```\n\n    [[1 1 3]\n    [4 4 3]\n    [4 3 2]]\n    --------------------------------------------------\n    [[1 4]\n    [2 4]\n    [1 4]]\n    --------------------------------------------------\n    [[ 6 20]\n    [15 44]\n    [12 36]]\n\n## 数组的索引和切片\n```python\narr1 = np.random.randint(1,9,(4,3,4))\nprint(arr1)\n\nprint('----------------多维数组的索引------------------')\nprint(arr1[0,1,2]) #numpy里面数组的索引是从外往里切\n\nprint('----------------多维数组的切片------------------')\nprint(arr1[:,1:3,1:3]) #注意numpy这里是左闭右开区间 \n\n\nprint('----------------numpy切片注意------------------')\n# 特别注意 numpy切片操作获取的是视图，修改数组会影响原来的数组 例子如下\nx = arr1[0,1,1:3]\nx[:] = 0\nprint('x =',x)\nprint('arr1 =',arr1) # 注意这边numpy数值的改变\n```\n    [[[6 5 2 6]\n    [3 7 8 1]\n    [3 4 8 3]]\n\n    [[8 5 4 5]\n    [3 5 4 2]\n    [8 5 4 1]]\n\n    [[5 3 6 2]\n    [2 5 2 8]\n    [7 1 4 1]]\n\n    [[7 5 2 3]\n    [4 3 1 5]\n    [3 5 3 5]]]\n    ----------------多维数组的索引------------------\n    8\n    ----------------多维数组的切片------------------\n    [[[7 8]\n    [4 8]]\n\n    [[5 4]\n    [5 4]]\n\n    [[5 2]\n    [1 4]]\n\n    [[3 1]\n    [5 3]]]\n    ----------------numpy切片注意------------------\n    x = [0 0]\n    arr1 = [[[6 5 2 6]\n    [3 0 0 1]\n    [3 4 8 3]]\n\n    [[8 5 4 5]\n    [3 5 4 2]\n    [8 5 4 1]]\n\n    [[5 3 6 2]\n    [2 5 2 8]\n    [7 1 4 1]]\n\n    [[7 5 2 3]\n    [4 3 1 5]\n    [3 5 3 5]]]\n## 花式索引和布尔索引\n```python\n# 花式索引\narr = np.arange(30).reshape(6,5)\nprint(arr)\nprint('----------------花式索引1---------------------------')\nprint(arr[[0,3,5]]) # 这边索引的是0,3,5行\n\nprint('----------------花式索引2---------------------------')\nprint(arr[np.ix_([0,3,5],[0,1,3])]) # 索引0,3,5行的0,1,3列数据\n\nprint('----------------Tips-------------------------------')\nprint('通过花式索引获取的新的数组是一个副本,新数组修改不会改变原数组')    \nx = arr[np.ix_([0,3,5],[0,1,3])]\nx[:] = 0\nprint('x =',x)\nprint('arr =',arr)\n```\n    [[ 0  1  2  3  4]\n    [ 5  6  7  8  9]\n    [10 11 12 13 14]\n    [15 16 17 18 19]\n    [20 21 22 23 24]\n    [25 26 27 28 29]]\n    ----------------花式索引1---------------------------\n    [[ 0  1  2  3  4]\n    [15 16 17 18 19]\n    [25 26 27 28 29]]\n    ----------------花式索引2---------------------------\n    [[ 0  1  3]\n    [15 16 18]\n    [25 26 28]]\n    ----------------Tips-------------------------------\n    通过花式索引获取的新的数组是一个副本,新数组修改不会改变原数组\n    x = [[0 0 0]\n    [0 0 0]\n    [0 0 0]]\n    arr = [[ 0  1  2  3  4]\n    [ 5  6  7  8  9]\n    [10 11 12 13 14]\n    [15 16 17 18 19]\n    [20 21 22 23 24]\n```python\n# 布尔索引\narr = np.array([1,2,3,4,5])\ncondition = [True,True,False,False,True]\nprint(arr[condition])\nprint('----------------布尔索引例子---------------------------')\nnames = np.array(['Leiy','Wuh','Syy'])\nscores = np.array([\n    [0,10,20],\n    [30,40,50],\n    [60,70,80]\n])\nclasses = np.array(['语文','数学','英语'])\nprint(scores[names == 'Leiy'])\nprint(names == 'Leiy')\nprint(names == 'Syy')\nprint(scores[(names == 'Leiy') | (names == 'Syy')])\n```\n    [1 2 5]\n    ----------------布尔索引例子---------------------------\n    [[ 0 10 20]]\n    [ True False False]\n    [False False  True]\n    [[ 0 10 20]\n    [60 70 80]]\n\n\n\n\n## 数组的转置与轴对换\n```python\nprint('----------------.T转置---------------------------')\narr = np.random.randint(1,9,(3,4))\nprint(arr.shape)\narr = arr.T\nprint(arr.shape)\nprint('----------------transpose转置--------------------')\narr = np.random.randint(1,9,(3,4,2))\nprint(arr.shape)\narr = arr.transpose(1,2,0) #transpose转置是根据传入的编号大小来决定转置的顺序\nprint(arr.shape)\n```\n    ----------------.T转置---------------------------\n    (3, 4)\n    (4, 3)\n    ----------------transpose转置--------------------\n    (3, 4, 2)\n    (4, 2, 3)\n\n\n\n## 数组的拉伸与合并\n```python\n# 数组的拉伸\narr = np.random.randint(1,9,(2,2))\nprint(arr)\nprint('----------------title横向拉伸--------------------')\nprint(np.tile(arr,2)) #横向拉伸两倍\nprint('----------------title横向纵向拉伸-----------------')\nprint(np.tile(arr,(2,3))) #横向拉伸3倍纵向拉伸2倍\n```\n    [[3 7]\n    [8 5]]\n    ----------------title横向拉伸--------------------\n    [[3 7 3 7]\n    [8 5 8 5]]\n    ----------------title横向纵向拉伸-----------------\n    [[3 7 3 7 3 7]\n    [8 5 8 5 8 5]\n    [3 7 3 7 3 7]\n    [8 5 8 5 8 5]]\n\n```python\n# 数组的合并\na = [1,2,3,4]\nb = [10,20,30,40]\nc = [[1,2,3,4],[5,6,7,8]]\nd = [[10,20,30,40],[50,60,70,80]]\n\nprint('----------------stack合并数组-----------------')\nprint(np.stack((a,),axis = 0))\nprint(np.stack((a,),axis = 1))\nprint(np.stack((a,b),axis = 0))\nprint(np.stack((a,b),axis = 1))\nprint('---------------vstack合并数组-----------------')\nprint(np.vstack((a,b)))\nprint('---------------hstack合并数组-----------------')  \nprint(np.hstack((a,b)))\nprint(np.hstack((c,d)))\n```\n    ----------------stack合并数组-----------------\n    [[1 2 3 4]]\n    [[1]\n    [2]\n    [3]\n    [4]]\n    [[ 1  2  3  4]\n    [10 20 30 40]]\n    [[ 1 10]\n    [ 2 20]\n    [ 3 30]\n    [ 4 40]]\n    ---------------vstack合并数组-----------------\n    [[ 1  2  3  4]\n    [10 20 30 40]]\n    ---------------hstack合并数组-----------------\n    [ 1  2  3  4 10 20 30 40]\n    [[ 1  2  3  4 10 20 30 40]\n    [ 5  6  7  8 50 60 70 80]]\n\n\n## 通用函数:快速的元素级数组成函数\n```python\n# 一元函数\narr = np.array([1,2,3,4,-5])\nprint('---------------绝对值函数-----------------')\nprint(np.abs(arr))\nprint(np.fabs(arr))\n\nprint('---------------sqrt函数------------------')\nprint(np.sqrt(np.abs(arr)))\n\nprint('---------------square函数----------------')\nprint(np.square(arr))\n\nprint('---------------exp函数-------------------')\nprint(np.exp(arr))\n\nprint('---------------log函数-------------------')\nprint(np.log(np.abs(arr)))\nprint(np.log10(np.abs(arr)))\n\nprint('---------------向上向下取整----------------')\narr = np.array([1.23,5.2,9.7])\nprint(np.ceil(arr))\nprint(np.floor(arr))\n\nprint('---------------四舍五入--------------------')\nprint(np.rint(arr))\nprint(np.round(arr,2))\n\nprint('---------------isnan/inf------------------')\narr = np.array([1,2,3,np.NaN,4,np.inf])\nprint(arr)\nprint(np.isnan(arr))\nprint(arr[~np.isnan(arr)]) #过滤到nan\nprint(np.isfinite(arr)) # 有穷的\nprint(np.isinf(arr)) # 无穷的\n\nprint('---------------三角函数---------------------')\nprint(np.sin([1,2,3,4]))\n```\n    ---------------绝对值函数-----------------\n    [1 2 3 4 5]\n    [1. 2. 3. 4. 5.]\n    ---------------sqrt函数------------------\n    [1.         1.41421356 1.73205081 2.         2.23606798]\n    ---------------square函数----------------\n    [ 1  4  9 16 25]\n    ---------------exp函数-------------------\n    [2.71828183e+00 7.38905610e+00 2.00855369e+01 5.45981500e+01\n    6.73794700e-03]\n    ---------------log函数-------------------\n    [0.         0.69314718 1.09861229 1.38629436 1.60943791]\n    [0.         0.30103    0.47712125 0.60205999 0.69897   ]\n    ---------------向上向下取整----------------\n    [ 2.  6. 10.]\n    [1. 5. 9.]\n    ---------------四舍五入--------------------\n    [ 1.  5. 10.]\n    [1.23 5.2  9.7 ]\n    ---------------isnan/inf------------------\n    [ 1.  2.  3. nan  4. inf]\n    [False False False  True False False]\n    [ 1.  2.  3.  4. inf]\n    [ True  True  True False  True False]\n    [False False False False False  True]\n    ---------------三角函数---------------------\n    [ 0.84147098  0.90929743  0.14112001 -0.7568025 ]\n```python\n# 二元函数\narr1 = np.random.randint(1,9,5)\narr2 = np.random.randint(1,9,5)\nprint(arr1)\nprint(arr2)\n\nprint('---------------mod函数---------------------')\nprint(np.mod(arr1,arr2)) #mod除法取余\n\nprint('---------------greater函数-----------------')\nprint(np.greater(arr1,arr2)) #比较大小\n\nprint('---------------less函数--------------------')\nprint(np.less(arr1,arr2)) #比较大小\n\nprint('---------------equal函数-------------------')\nprint(np.equal(arr1,arr2)) #比较大小\n\n\narr1 = np.array([0,1,1,0])\narr2 = np.array([1,0,1,0])\nprint('---------------logical_and函数--------------')\nprint(np.logical_and(arr1,arr2))\nprint('---------------logical_or函数---------------')\nprint(np.logical_or(arr1,arr2))\nprint('---------------logical_xor函数--------------')\nprint(np.logical_xor(arr1,arr2))\nprint('---------------powe函数---------------------')\nprint(np.power(arr1,2)) #指数函数\n\n```\n    [6 7 7 3 5]\n    [3 4 4 1 3]\n    ---------------mod函数---------------------\n    [0 3 3 0 2]\n    ---------------greater函数-----------------\n    [ True  True  True  True  True]\n    ---------------less函数--------------------\n    [False False False False False]\n    ---------------equal函数-------------------\n    [False False False False False]\n    ---------------logical_and函数--------------\n    [False False  True False]\n    ---------------logical_or函数---------------\n    [ True  True  True False]\n    ---------------logical_xor函数--------------\n    [ True  True False False]\n    ---------------powe函数---------------------\n    [0 1 1 0]\n\n## 聚合函数\n```python\narr = np.random.randint(1,9,(3,3))\nprint(arr)\nprint('-'*50)\nprint('最小值:',arr.min())\nprint('最大值:',arr.max())\nprint('平均值:',arr.mean())\nprint('标准差:',arr.std())\nprint('最小值:',arr.min(axis = 0))\nprint('最小值:',arr.min(axis = 1))\n```\n    [[3 2 1]\n    [5 1 5]\n    [3 8 7]]\n    --------------------------------------------------\n    最小值: 1\n    最大值: 8\n    平均值: 3.888888888888889\n    标准差: 2.3778816176702997\n    最小值: [3 1 1]\n    最小值: [1 1 3]\n\n\n## np.where函数\n```python\narr1 = np.array([1,3,5,2,4])\narr2 = np.array([2,2,6,3,3])\nprint(arr1)\nprint(arr2)\nprint('-'*50)\nprint(np.where(condition,arr1,arr2)) #类似C语言里面的三元运算符\n```\n\n    [1 3 5 2 4]\n    [2 2 6 3 3]\n    --------------------------------------------------\n    [1 3 6 3 4]\n\n## np.unique函数\n```python \n#  去重函数(字面意思)\narr = np.random.randint(1,5,9)\nprint(arr)\nprint(np.unique(arr))\n```\n    [3 4 4 1 2 4 1 3 4]\n    [1 2 3 4]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["NumPy"],"categories":["NumPy总结"]},{"title":"Matplotlib总结","url":"/2019/03/13/matplotlib/","content":"# Matplotlib概述\n> Python最常用的绘图库,提供了一整套十分适合交互式绘图的命令API,比较方便的就可以将其嵌入到GUI应用程序中。\n\n<br>\n<br>\n<br>\n\n# 线图\n## figure使用\n```python\ndata = np.arange(-3,3,0.1)\nx = np.sin(data)\ny = np.cos(data)\n\n\n# 绘图\nplt.figure() #plt.figure(figsize = (8,6)) 这边是可以指定画布的大小的\nplt.plot(data,x)\nplt.show()\n\nplt.figure() #plt.figure(figsize = (8,6)) 这边是可以指定画布的大小的\nplt.plot(data,y)\nplt.show()\n```\n![matplotlib1](https://i.loli.net/2018/08/24/5b7f71178c03b.png)\n## 颜色，标记，线型\n```python\nx = [1,3,5]\ny = [2,4,3]\nplt.plot(x,y,color = 'r',linestyle = '--',marker = 'o',label = 'x-line')\nplt.legend()\nplt.show()\n```\n![matplotlib2](https://i.loli.net/2018/08/24/5b7f71e8c89e6.png)\n\n## 刻度，标题，标签，图例\n```python\nx = [1,3,5]\ny = [2,4,3]\n\n# 创建图形\nplt.figure()\n# 画图\nplt.plot(x,y,'r--',label = 'x-line')\n#生成图例\nplt.legend(loc = 'upper left')\n\n#设置标题\nplt.title('scores')\n\n# 设置x，y标签\nplt.xlabel('x axis')\nplt.ylabel('y axis')\n\n#设置刻度的范围\n# plt.xlim((1,10))\n# plt.ylim((1,10))\n\n#设置刻度\n# plt.xticks(np.arange(1,5))\n# plt.yticks(np.arange(1,10))\n\nplt.xticks(np.arange(1,6,1),[str(i) + 'mon'   for i in range(1,6,1)])\nplt.yticks(np.arange(1,10))\n\n# plt.xticks(np.arange(1,6,1),['1mon','2mon','3mon','4mon','5mon','6mon'])\n# plt.yticks(np.arange(1,10))\n\n\n# 获取坐标轴信息 固定操作\nax = plt.gca()\nax.spines['right'].set_color(None)\nax.spines['top'].set_color(None)\n\nplt.show()\n```\n![matplotlib3](https://i.loli.net/2018/08/24/5b7f72a8935dd.png)\n\n## subplot子图\n```python\nx1 = [1,3,5]\ny1 = [2,4,5]\n\nx2 = [1,4,5]\ny2 = [3,2,5]\n\n#创建图形\nplt.figure()\n\nplt.subplot(221)\nplt.plot(x1,y1,'r--')\n\nplt.subplot(222)\nplt.plot(x2,y2,'b--')\n\nplt.show()\n```\n![matplotlib4](https://i.loli.net/2018/08/24/5b7f734cef302.png)\n\n## 子图面向对象的写法\n```python\nx1 = [1,3,5]\ny1 = [2,4,5]\n\nx2 = [1,4,5]\ny2 = [3,2,5]\n\n#创建图形\nfig = plt.figure()\nax1 = fig.add_subplot(221)\nax1.plot(np.random.randn(50).cumsum(),'r--')\n\nax2 = fig.add_subplot(222)\nax2.plot(np.random.randn(50).cumsum(),'b--')\n\nax3 = fig.add_subplot(223)\nax3.plot(np.random.randn(50).cumsum(),'y--')\n\nax4 = fig.add_subplot(224)\nax4.plot(np.random.randn(50).cumsum(),'g--')\n\nplt.show()\n```\n![matplotlib5](https://i.loli.net/2018/08/24/5b7f73c9d161b.png)\n\n## subplot子图\n```python\n# 生成一个figure以及子图列表\nfig,ax = plt.subplots(2,2) # 2行2列 本质是一个列表\n\nfor i in range(2):\n    for j in range(2):\n        ax[i][j].plot(np.random.randn(50).cumsum(),'r--')\n\nplt.savefig('子图')\nplt.show()\n```\n![matplotlib6.png](https://i.loli.net/2018/08/24/5b7f742b40c02.png)\n\n<br>\n<br>\n<br>\n\n# 柱状图\n```python\n# 设置数据\nheight = np.array([100,200,300,400])\n\n# 设置数据标量\nleft = np.arange(1,5,1) # 4 x\n\n# 设置柱子宽度\nn = 4\nwidth = 0.8 / n\n\n# 创建figure\nplt.figure()\n\nplt.title('City')\n\nplt.xlabel('month')\nplt.ylabel('money')\n\n# 画图\nplt.bar(left,height,width = width,color = 'lightskyblue',align = 'center',label = 'SH') \nplt.bar(left-width,height + 20,width = width,color = 'red',align = 'center',label = 'BJ') #第一个参数是设定偏移量\nplt.bar(left+width,height + 10,width = width,color = 'y',align = 'center',label = 'SZ')\nplt.legend()\n\nplt.show()\n```\n![matplotlib7.png](https://i.loli.net/2018/08/24/5b7f75832c50c.png)\n\n<br>\n<br>\n<br>\n\n# 直方图\n```python\nmu, sigma = 100,15\nx = np.random.randn(1000) * mu * sigma\n\n#绘图\nplt.figure()\nplt.hist(x,100,alpha = 0.5,color = 'red') #第二个参数用来设定柱子个数 第三个参数用来设定颜色深浅\n\nplt.grid(True) #加上网格\n\nplt.show()\n```\n![matplotlib8.png](https://i.loli.net/2018/08/24/5b7f77f013b91.png)\n\n\n<br>\n<br>\n<br>\n\n# 散点图\n```python\n# 设置数据\nx = np.random.randn(1000)\ny = np.random.randn(1000)\n\n# plt.scatter(x,y)\n# plt.scatter(x,y,c = np.random.rand(1000))\n# plt.scatter(x,y,c = np.random.rand(1000),s = np.random.rand(1000) * 50)\nplt.scatter(x,y,c = np.random.rand(1000),s = np.random.rand(1000) * 50,alpha = 0.8)\nplt.title('money')\n\nplt.show()\n```\n![matplotlib9.png](https://i.loli.net/2018/08/24/5b7f78ba64bd6.png)\n\n<br>\n<br>\n<br>\n\n# 饼图\n```python\n# 设置数据\nx = [15,25,30,30]\n\n#设置颜色\ncolor = ['r','yellow','green','blue']\n\n#设置每一块离开中心的距离\nexplode = [0.2,0,0,0]\n\n#每一块的文字说明\nlabels = ['yule','shenghuo','grilfriend','game']\n\n\nplt.figure()\n\n\n\n\n# 绘制饼图\nplt.pie(x,explode = explode,labels = labels, colors = color,startangle = 90,shadow = True ,labeldistance = 1.2,autopct = '%.1f%%')\n\nplt.title('money')\n# 设置圆图\nplt.axis('equal')\nplt.show()\n```\n![matplotlib10.png](https://i.loli.net/2018/08/24/5b7f7948c281d.png)\n\n\n\n\n\n\n","tags":["Matplotlib"],"categories":["Matplotlib总结"]},{"title":"Markdown语法之公式编辑","url":"/2019/03/13/Markdown(2)/","content":"\n# MathJax引擎配置\n首先我们选用MathJax引擎，插入以下代码至你要编辑的MD文件中\n```\n<script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default\"></script>\n```\n由于我的博客采用的是 hexo+next 的框架，所以关于hexo下配置MathJax引擎的详情可以[点这里](https://ranmaosong.github.io/2017/11/29/hexo-support-mathjax/)\n\n# Markdown公式插入方式\n## 行间插入\n```\n  格式: $$ (此处插入公式) $$\n```\n行间插入的意思是公式单独占一行，不予其他文字混淆\n## 行内插入\n```\n  格式: \\\\( 此处插入公式 \\\\)\n```\n行内插入的意思与行间插入刚好相反\n\n# 实例代码\n在这里先强势安利一波Latex在线编辑器[Mathcha](https://www.mathcha.io/)这款在线Latex编辑器不仅可以让你在不了解Latex书写规则的情况下编写出公式还可以编辑图表于绘图\n\n## 实例\n通过 '\\' 键快速调出Mathcha的Show Suggestion Box按钮 \n具体的教学视频[Mathcha教学视频](https://www.youtube.com/watch?v=ff0H6w561z8)\n```\n$$\nf( x) \\ =\\ \\left[\\frac{a\\ +\\ b}{c}\\right] +\\int ^{2}_{1} x^{2}\n$$\n```\n$$ f( x) \\ =\\ \\left[\\frac{a\\ +\\ b}{c}\\right] +\\int ^{2}_{1} x^{2} $$\n<br>\n```\n$$\nf(x) \\ =\\ \\begin{cases} \n10 & x< 20\\\\\\\n19 & x\\geq 20\n\\end{cases}\n$$\n```\n$$\nf(x) \\ =\\ \\begin{cases}\n10 & x< 20\\\\\\\n19 & x\\geq 20\n\\end{cases}\n$$\n<br>\n```\n$$\nA\\ =\\ \\begin{bmatrix}\n1 & 2 & 3\\\\\\\n4 & 5 & 6\\\\\\\n7 & 8 & 9\n\\end{bmatrix}\n$$\n```\n$$\nA\\ =\\ \\begin{bmatrix}\n1 & 2 & 3\\\\\\\n4 & 5 & 6\\\\\\\n7 & 8 & 9\n\\end{bmatrix}\n$$\n\n好啦！ 到现在你已经学会怎么使用Latex在线编辑器在Markdown里编辑公式了，赶快试试吧！\n\n# 参考资料\n[如何在hexo中支持Mathjax](https://ranmaosong.github.io/2017/11/29/hexo-support-mathjax/)\n[Hexo博客next主题数学公式渲染问题](http://doraemonzzz.com/2018/05/15/Hexo%E5%8D%9A%E5%AE%A2next%E4%B8%BB%E9%A2%98%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98/)\n[MarkDown 插入数学公式实验大集合](https://juejin.im/post/5a6721bd518825733201c4a2)\n[在markdown里如何写数学公式](https://magicly.me/markdown-math/)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Markdown"],"categories":["Markdown语法之公式编辑"]},{"title":"Markdown语法之基本语法","url":"/2019/03/13/Markdown(1)/","content":"# Markdown标题设置\nMarkdown标题的设置通过设置 # 的个数来确定而 # 个数的范围是 1～6\n\n```\n    # 一级标题\n    ## 二级标题\n    ### 三级标题\n    #### 四级标题\n    ##### 五级标题\n    ###### 六级标题\n    ps: # 和标题中间有空格\n```\n### 标题效果展示\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n<br>\n<br>\n<br>\n\n\n\n# Markdown列表设置\n```\n    ### 无序列表\n    * 1\n    * 2\n    * 3 \n    ### 有序列表\n    1. 1\n    2. 2\n    3. 3\n    \n```\n### 列表效果展示\n有序列表\n1. 1\n2. 2\n3. 3\n\n无序列表\n* 1 \n* 2\n* 3 \n\n<br>\n<br>\n<br>\n\n# Markdown引用\n```\n> 这里是引用 注意文本和符号之间的空格 \n```\n### 引用效果展示\n> 这里是引用 注意文本和符号之间的空格\n\n<br>\n<br>\n<br>\n\n\n\n\n\n\n# Markdown换行\n```\nMarkdown中使用换行使用 <br> 实现\n```\n### 换行效果展示\n> 引用1\n> 引用2\n> 引用3\n\n<br>\n<br>\n<br>\n\n\n\n\n\n\n# 图片和超链接\n## 超链接\n```\nMarkdown中插入超链接的格式为  [link text](URL 'title text')\n如：[Baidu](http://www.baidu.com)\n```\n### 超链接效果展示\n[Baidu](http://www.baidu.com)\n\n## 图片\n```\nMarkdown中插入图片于超链接类似 只不过前面多了 ！\n格式为 ！[link text](URL 'title text')\n建议使用sm.ms生成图片url 网站为 https://sm.ms/\n\n如：  ![姚贝娜](https://i.loli.net/2018/08/12/5b700577810ed.jpg)\n```\n### 图片效果展示\n![姚贝娜](https://i.loli.net/2018/08/12/5b700577810ed.jpg)\n\n<br>\n<br>\n<br>\n\n\n\n\n\n\n# 粗体与斜体\n```\n*这里是斜体 *  <br>\n**这里是粗体** <br>\n***这里是粗斜体***\n```\n### 粗体与斜体效果展示\n*这里是斜体 *  \n**这里是粗体** \n***这里是粗斜体***\n<br>\n<br>\n<br>\n\n\n\n\n# 表格\n```\n表格的生成在Markdown中比较麻烦！\n:--- 代表左对齐\n:--: 代表居中对齐\n---: 代表右对齐\n\n| Tables        | Are           | Cool  |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n\n```\n### 表格效果展示\n| Tables        | Are           | Cool  |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n<br>\n<br>\n<br>\n\n\n\n\n# 删除线\n```\n这就是 ~~删除线~~\n```\n### 删除线效果展示\n这就是 ~~删除线~~\n<br>\n<br>\n<br>\n\n\n\n\n \n# 代码框\n```\n在Markdown中插入代码框使用的是六个`(esc下面1左面的按键) 代码处于三个`的中间\n```\n\n\n### 代码框效果展示\n```c \n    void main()\n        {\n            print('Hello World!')\n        }\n```\n<br>\n<br>\n<br>\n\n\n# 分割线\n```\n    分割线使用三个星号\n    如： ***\n```\n### 分割线效果展示\n***\n<br>\n<br>\n\n\n\n# 参考资料\n\n[Markdown入门参考](http://xianbai.me/learn-md/index.html)\n[Markdown入门指南](https://www.jianshu.com/p/1e402922ee32/)\n\n\n\n\n \n\n\n\n\n","tags":["Markdown"],"categories":["Markdown语法之基本语法"]},{"title":"高效阅读英文文献思维和方法","url":"/2019/03/13/live-高效阅读英文文献思维和方法/","content":"\n\n![image01.png](https://i.loli.net/2018/10/20/5bcaad10a5241.png)\n\n# 阅读目的\n* 整体上了解方向知识(起步求稳扎实)\n  * 教材(英文)\n  * 学位论文(引言)\n* 提炼科研想法\n  * 科研好像法的诞生\n* 寻找目标方法\n  * Research Methodology\n    * Experiental/Materials and Methods\n    * Approach/Methodology\n    * Theoretical and Computational Details\n* 寻找国际同行\n  * 查询作者信息和作者单位,引用量\n  * 论文数量\n* 找同类研究\n  * 搜索相关的内容，比较同类研究和不同和相似\n* __调查期刊影响力和同行期刊__\n  * 期刊审稿时间 投稿到收录时间很短表明是主审稿人邀请某个人写的通常质量比较高\n  * 期刊排名和影响因子\n  * 查看同行期刊(webofscience)\n* 提高英语词汇量和写作能力\n* 入门专业知识\n\n# 如何判断,筛选和整理论文\n* __文献管理软件__\n    * 将有限的时间花在前期判断,筛选上\n    * 电子版文件夹管理和打印版阅读记笔记\n* __实用思维和步骤__\n    * __优化和缩小范围__\n        * 不断增加搜索约束,缩小搜索范围\n    * __判断内容相关度和论文质量__\n         ![image02.png](https://i.loli.net/2018/10/20/5bcabe072b01a.png)\n        * 找到那种让你wow的论文       \n    * 精读和泛读,并下载\n    * 标注题目,发表年份和精读泛读,并分类\n    * 打印并归类精读论文,先精读,后续再增加泛读论文\n\n# 阅读的方法和技巧\n## __如何阅读和参考教材?__\n  * __确保高质量__\n  * __作者信息__\n  * __目录Contents__\n  * Subject Index + 知识百科\n  * 基本概念和成熟方法\n  * 不成熟的研究成果？\n  * __较真程度: 教材 < 论文__\n## __如何奠定高效和快速阅读的基础?__\n  * 拒绝水文\n  * __有效筛选文章__\n  * 合理安排阅读顺序,根据目的选择性阅读\n  * 只有精读,才能浮想联翩\n  * __辐射阅读__\n  * 交流论文内容\n  * 做一点尝试性模仿研究\n## __有效整理笔记和整理内容?__\n    ![image03.png](https://i.loli.net/2018/10/20/5bcac7ec8815c.png)\n\n    ![image04.png](https://i.loli.net/2018/10/20/5bcac6578a77b.png)\n## __如何开展阅读总结,反思和提问?__\n    * 读文章四个层次 理解,质疑,总结,提炼\n    ![image05.png](https://i.loli.net/2018/10/20/5bcac78273fdd.png) \n    ![image06.png](https://i.loli.net/2018/10/20/5bcac84d6f6fd.png)    \n## __如何提高阅读论文速度和效率?__\n    * __比起速度,理解内容更重要！！__\n    ![image07.png](https://i.loli.net/2018/10/20/5bcac8dc88f19.png)\n    ![image08.png](https://i.loli.net/2018/10/20/5bcac9578b5a0.png)\n\n## __如何构建自己的研究体系?__\n  * __懂得站在巨人的肩膀上__\n  ![image09.png](https://i.loli.net/2018/10/20/5bcaca83dfb24.png)\n\n# 其他\n* 看不懂数学公式 1.对应的教材  2.看论文的目的 如果目的不是了解方程的推导\n* 遇到不会的单词必须查,查多了才会有理解\n* 使用 1.谷歌 hot research topic 2.综述论文 3.国际会议 4.导师 5.webofscience 查找前沿热点\n* 使用英文去查找英文的意思\n* '*'代表和crack相关的词\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["英文文献"],"categories":["高效阅读英文文献思维和方法"]},{"title":"建立专属的时间管理系统","url":"/2019/03/13/live-时间管理/","content":"\n# 基础---时间管理的好方法\n\n* 任务前:to do list\n* 任务中:番茄工作法\n* 任务后:时间记录法\n\n\n## 任务前\n* 选取合适的时间步长,列出明天的计划\n* 使用四像限工作法\n* 适量适度原则:依照对自己的评估制定计划\n\n![四像限工作法.png](https://i.loli.net/2018/09/24/5ba8c8e940eb3.png)\n\n## 任务中\n* 灵活处理\n* 寻找适合自己的番茄工作时间\n* 因任务而异，番茄工作法容易拆分，有明确的目标和界定任务\n\n## 任务后\n* 记录纯粹工作时间\n* 记录精准\n* 适合自己而非追求完美和完善\n\n\n# 提升---专注力管理\n* 注重输出能力\n* 成就感和挫败感的平衡\n* 分配专注力\n\n## 注重输出能力\n* 费曼学习法 \n> 1.选择一个概念\n> 2.想象你正要把这个概念教给一个新生\n> 3.如果遇到问题原路返回，\n> 4.简化你的描述语言，或者创建一个类比，以便让别人更好的理解。\n* 费慢学习法拓展\n> 1.回忆整本书脉络，思路，论证过程。作者让你最佩服的地方是什么？如果让你来写，你会怎么写？\n> 2.看过一篇paper能不能写出文件综述，思维导图。\n\n## 成就感和挫败感的平衡\n* 按照自己专心做事的时候的能力制定，这样是一个比较高的要求，因此你会相对的觉得自己‘努力就可以完成’\n\n## 分配专注力\n* 处理专注力和四象限的冲突\n* 不要奢望完成专注力和实际差距太大的事情，选择合适的任务\n* 在每天to do list中调整，总结经验\n* 学会专注力排序\n![专注力.png](https://i.loli.net/2018/09/24/5ba8cd64f32fa.png)\n\n## 实践中的方法\n* 如何将好奇心变为能力培养？\n> 能力培养——信息收集、处理和输出的能力\n* 如何度过艰难时刻？\n> 克服恶性循环，把计划难度降低，但并不完全抛弃计划\n* 任务被打断怎么办？\n> 四象限原则 + 使用书签和收藏\n\n# 优化---如何利用碎片花时间\n* 简单任务优先原则\n* 利用环境优势\n* 精力碎片下，多做整合和回忆类任务\n\n\n# 其他问题\n\n问:听了一天课，没什么收获\n答:整理思绪，一小时回顾，遗忘曲线\n\n\n问:工作后留给自己的时间少了很多，如何利用回家后不够多的时间得到一些需要系统学习才能达成的知识？\n答:筛选最需要的，搞清主要矛盾，不要对速成抱有太大的希望\n\n\n处理事件任务制方式，并非时间制\n\ncrush course\n\n# 参考资料\n[建立专属的时间管理系统](https://www.zhihu.com/lives/769214248550166528)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["时间管理"],"categories":["建立专属的时间管理系统"]},{"title":"如何开展高质量英文文献调研","url":"/2019/03/13/live-如何开展高质量英文文献调研/","content":"\n问:作为本科生，对本领域的专业词汇还不甚熟悉，因为不清楚中文表达对应的地道英文表述，文献搜索效率也大大降低，请问如何解决该问题？\n答: 1.找专业英文教材 2.综述英文论文 3.专业学术翻译软件(中国知网学术翻译) \n\n问:老师您好，我是 作为人工智能基础研究岗位的从业者，想请教您几个问题：1. 如何通过读论文构建自己在某个领域的知识树。2. 如何通过梳理自己对某个领域学者关系脉络的认识。3. 如何提交自己在学界和业界的影响力。\n答:1.除了论文外还需要阅读经典的教材，论文的作者和关系\n2.了解这个领域的几个阵营，阵营之间的争辩的点\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["英文文献"],"categories":["如何开展高质量英文文献调研"]},{"title":"患上[努力焦虑症]，怎么办？","url":"/2019/03/13/live-患上努力焦虑症/","content":"\n![焦虑.jpg](https://i.loli.net/2018/10/20/5bca842e59d8a.jpg)\n\n# 三种努力\n\n* 为了目标而努力  \n* 追求努力的状态的努力 努力是一种自我辩解 营造在路上的感觉 ！！！\n* 追求努力的感觉的努力\n\n__前者非常清楚自己的目标和努力的关系后两者并不清楚,不要营造一种努力的假象,你只是看起来很努力__\n\n# 焦虑的本质和努力背后的动机\n对不能控制的东西比较鸡血 对能控制的东西比较丧 \n对不能控制的东西顺其自然 对能控制的东西更为精进\n而真正的努力需要同时把握\n焦虑本本质是一种失控对能控制的东西不上进 对不能控制的领域强行控制\n__那些大的目标并不是用来实现的而是用来缓解焦虑，想要缓解焦虑这些目标就必须远大，可这些目标并不是用来实现，了解焦虑的来源__\n\n# 持续的努力是如何维持的？\n* 忘我，沉浸在追求目标的过程，呈现出一种福流的状态，沉浸在自己所能够控制的事物中,介于一种持续追求目标，却又不看重目标的状态\n\n# 什么是努力的正确姿势？\n* 真实的努力需要你盯着你能做的事情而不是那些你不能控制的事情,多去思考那些你能够控制的事情，而不是强行控制那些你做不了的事情\n* 行动的努力，控制能控制的事情\n* 一次只是制定一个目标\n* __真正有效的计划是控制，每一个不可控的东西都有可控的成分存在,把这些真正可控的东西做成计划，计划无法让你增加控制感，这就不是一个好的计划__\n* __真正的努力是控制我所能够控制的接纳我所控制不了的,从感受上，因为专注于此时此地的东西，它能制造更多的福流。从思维上，它看到的是能做的事情，而不是盯着不能做的事情。从行动上，通过做那些能控制的部分，来把事情往前推进。__\n\n# 忠告\n* 不要总去回想你不能控制的过去，多想想你能控制的未来，__活在当下__\n* 学会选择面对苦难的选择\n* 生活是为了工作还是工作是为了生活\n* 不需要向别人证明你自己，只需要向自己证明你自己\n* __不要制定那种只要一停下来就觉得失败了的那种目标，多制定那种只要做一次就觉得自己成功了的那种目标，比如一周跑一次步__\n* __制定计划要在自己可控的范围之内，盲目的制定很多不可控的东西只是为了缓解你的焦虑，提供给你进步的幻想。__\n* 如何完成多个目标？学会在一段时间内只有一个目标\n* 知识和技能积累需要时间根植于真实\n\n  \n![assj.jpg](https://i.loli.net/2018/10/20/5bca8a43d1e50.jpg)\n\n\n\n\n\n\n\n\n\n\n\n","tags":["时间管理"],"categories":["患上[努力焦虑症]，怎么办？"]},{"title":"1.2 Neural networks basics","url":"/2019/03/13/deeplearning1_2/","content":"\n<script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default\"></script>\n\n# 什么是分类问题？\n>在分类问题中，我们尝试着去预测结果是否是属于某一类(例如正确或错误),我们将这类问题称为分类问题\n\n# 逻辑回归\n逻辑回归本质上等于在线性回归的输出端口加上一个sigmoid函数如果输出值大于0.5判断为1类如果小于0.5则判断为0类\n![LogReg_kiank.png](https://i.loli.net/2018/09/17/5b9f043aee4b0.png)\n# 代价函数\n线性回归中损失函数：\n\n$$\n    Loss\\ =\\ \\frac{1}{2}\\left( \\ \\hat{y} \\ -y\\ \\right)^{2}\n$$\n\n如果在分类问题中使用的线性回归的代价函数，我们发现最终在代价函数的优化问题上会出现许多的局部极小值，不利于对参数的优化，所以我们采用其他的代价函数\n\n损失函数：\n\n$$\n    Loss=-\\left( ylog\\hat{y} \\ +\\ ( 1-y) log\\left( 1-\\hat{y}\\right)\\right)\n$$\n\n代价函数：\n$$\nJ( w,b) \\ =\\ \\frac{1}{m}\\sum ^{m}_{i\\ =\\ 1} Loss\\left(\\hat{y} \\ ,y\\right)\n$$\n\n逻辑回归代价函数直观理解：\n在理解逻辑函数之前我们先回顾下log函数的图像\n\n![f(x).png](https://i.loli.net/2018/09/17/5b9f0fe5035ec.png)\n\n如果实际结果 y = 1 则损失函数变为 \n\n\\\\ Loss\\left(\\hat{y} \\ ,y\\right) \\ =\\ -log\\hat{y} \\\\\n\n从log函数图像可知此时如果我们预测的结果是0(与实际结果相反)则将会付出一个接近无穷的代价相反如果我们预测的结果是1(与实际结果相同),则我们将只会付出0代价\n类似的如果实际结果 y = 0，则代价函数变为\n\n\\\\ Loss\\left(\\hat{y} ,y\\right) \\ =\\ -\\left( log\\left( 1\\ -\\ \\hat{y}\\right)\\right) \\\\\n\n此时如果我们预测结果为1(与实际结果相反)则会付出一个很大的代价，而如果我们预测的结果与实际相同则我们付出的代价为0即不会付出任何代价。\n\n\n\n# 梯度下降\n深度学习的优化问题大多使用梯度下降，或者是梯度下降的优化版本，前面我们已经知道了分类问题的代价函数，现在我们使用梯度下降来优化我们的参数\n# 反向传播\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["deeplearning"],"categories":["1.2 Neural networks basics"]},{"title":"1.1 Introduction to Deep Learning","url":"/2019/03/13/deeplearning1_1/","content":"# 神经网络的基本介绍\n## 什么是神经网络？\n在回答这个问题之前让我们看看我们的大脑的神经元是怎么运作的？\n\n\n![神经元](https://i.loli.net/2018/08/14/5b72b6627d275.png)\n大脑中的每一个神经元都可以被认为是一个处理单元(processing unit/Nucleus)，他包含许多的输入(树突)并且有一个输出(轴突)，每一个神经元都是一个学习模型，他们接受来自其他神经元的信息并通过计算将结果输出给其他神经元，所以神经网络是大量神经元相互链接并通过电脉冲来交流的网络。\n\n\n## 神经网络的建立\n在介绍标准的神经网络之前先我们先来看一个最简单的神经网络图\n![SimpleNN](https://i.loli.net/2018/08/15/5b7444d8b3199.jpg)\n类比之前介绍的有关神经元的概念我们可知这边输入对应的是神经元的树突而这边的输出对应的上面的轴突，所以这个最简单的神经元所做的事情就是输入一组其他神经元输出的数据然后经过计算将其结果输出给其他神经元。\n\n\n介绍完单个的神经网络后我们来看看标准的神经网络结构\n![StandardNN](https://i.loli.net/2018/08/16/5b744e4e6aa9b.jpg)\n与上面单个神经元网络所不同的是标准的神经元网络的每一个神经元存在很多个输入同时也存在很多个输出，习惯上我们将第一列神经元称为输入层最后一列神经元称为输出层而在他们中间的神经元称之为隐藏层，同样习惯上我们称一个神经网络有多少层时只计算隐藏层和输出层而不算输入层，如上图所示的神经网络图总共有2层。\n\n\n除了上面提及的标准的神经网络结构还存在其他类型的神经网络结构分别是CNN和RNN\n![NN_Example](https://i.loli.net/2018/08/16/5b759a24f1f3a.png)\n关于RNN/CNN 这里不做多讲，以后会进行介绍\n  \n不同的神经网络结构也自然导致了不同的应用场景，下面列举了不同神经网络结构的应用场景\n\n| Input(x)         | Output(y)              | Application           |\n| -------------    |:-------------:         | -----:                |\n| Home features    | Price                  | Real Estate           |\n| Ad,user info     | Click on ad?(0/1)      | Online Advertising    |\n| Image            | Object(1,..,1000)      | Photo tagging         |\n| Audio            | Text transcript        | Speech recognition    |\n| English          | Chinese                | Machine translation   |\n| Image,Radar info | Position of other cars | Autonomous driving    |\n\n最后，不得不提一下的是近年来AI蓬勃发展的主要原因有三个\n* 数据集的扩大\n* 计算机计算能力的提升\n* 算法的改善\n\n# 参考资料\n[deeplearning.ai笔记](https://github.com/mbadry1/DeepLearning.ai-Summary)\n[deeplearning.ai专项课程](https://www.coursera.org/specializations/deep-learning)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["deeplearning"],"categories":["1.1 Introduction to Deep Learning"]}]